// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGInventoryComponentEquipment.h"
#include "Equipment/FGEquipment.h"
#include "Net/UnrealNetwork.h"

UFGInventoryComponentEquipment::UFGInventoryComponentEquipment() : Super() {
	this->mOverrideEquipmentInSlot = nullptr;
	this->mEquipmentInSlot = nullptr;
	this->mEquipmentInventorySlot = EEquipmentSlot::ES_NONE;
	this->mActiveEquipmentIndex = -1;
}
AFGEquipment* UFGInventoryComponentEquipment::GetEquipmentInInventory() const{ return nullptr; }
EEquipmentSlot UFGInventoryComponentEquipment::GetEquipmentSlotEnum() const{ return EEquipmentSlot(); }
void UFGInventoryComponentEquipment::SetEquipmentSlotEnum(EEquipmentSlot inSlot){ }
void UFGInventoryComponentEquipment::SetOverrideEquipment(AFGEquipment* equipment){ }
AFGEquipment* UFGInventoryComponentEquipment::GetStackEquipmentActorAtIdx(const int32 index) const{ return nullptr; }
int32 UFGInventoryComponentEquipment::FindSlotForSlottedInEquipment(const AFGEquipment* equipment) const{ return int32(); }
void UFGInventoryComponentEquipment::CycleEquipment(int32 dir){ }
void UFGInventoryComponentEquipment::SetActiveIndexWithDefaultItem(int32 index){ }
void UFGInventoryComponentEquipment::SetActiveIndex(int32 index, TOptional<FInventoryItem> itemAtCurrentIndex){ }
bool UFGInventoryComponentEquipment::ContainsItemTypeAndHasEnoughSpaceForItem(FInventoryItem item){ return bool(); }
FDelegateHandle UFGInventoryComponentEquipment::BindOnActiveEquipmentChanged(const FOnActiveEquipmentChanged::FDelegate &Delegate){ return FDelegateHandle(); }
void UFGInventoryComponentEquipment::SetActiveEquipment(AFGEquipment* equipment){ }
void UFGInventoryComponentEquipment::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(UFGInventoryComponentEquipment, mSlottedInEquipments);
	DOREPLIFETIME(UFGInventoryComponentEquipment, mEquipmentInSlot);
	DOREPLIFETIME(UFGInventoryComponentEquipment, mEquipmentInventorySlot);
	DOREPLIFETIME(UFGInventoryComponentEquipment, mActiveEquipmentIndex);
}
void UFGInventoryComponentEquipment::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void UFGInventoryComponentEquipment::OnItemsAdded(const int32 idx, const int32 num, UFGInventoryComponent* sourceInventory){ }
void UFGInventoryComponentEquipment::OnItemsRemoved(int32 idx, int32 num, const FInventoryItem& item, UFGInventoryComponent* targetInventory){ }
void UFGInventoryComponentEquipment::ActivateEquipment(){ }
void UFGInventoryComponentEquipment::RemoveActiveEquipment(){ }
void UFGInventoryComponentEquipment::AdjustSlottedInEquipmentsSize(){ }
bool UFGInventoryComponentEquipment::AttemptSpawnEquipmentForSlot(int32 slotIndex){ return bool(); }
bool UFGInventoryComponentEquipment::AttemptRemoveEquipmentFromSlot(int32 slotIndex){ return bool(); }
bool UFGInventoryComponentEquipment::FilterEquipmentClasses(TSubclassOf< UObject > object, int32 idx) const{ return bool(); }
AFGCharacterPlayer* UFGInventoryComponentEquipment::GetOwningCharacter(){ return nullptr; }
void UFGInventoryComponentEquipment::OnRep_ActiveEquipmentIndex(){ }
void UFGInventoryComponentEquipment::OnRep_ActiveEquipment(){ }
void UFGInventoryComponentEquipment::OnRep_SlottedInEquipments(){ }
