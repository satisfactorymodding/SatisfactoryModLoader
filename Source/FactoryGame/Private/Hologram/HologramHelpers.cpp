// This file has been automatically generated by the Unreal Header Implementation tool

#include "Hologram/HologramHelpers.h"

UStaticMeshComponent* FHologramHelpers::CreateClearanceMeshComponent( USceneComponent* attachTo,  UFGClearanceComponent* fromClearanceBox){ return nullptr; }
void FHologramHelpers::SetClearanceMeshData( UStaticMeshComponent* clearanceMesh,  UFGClearanceComponent* fromClearanceBox){ }
UStaticMeshComponent* FHologramHelpers::CreateConnectionRepresentation( UFGConnectionComponent* connectionComponent, bool isOutput, float heightOffset){ return nullptr; }
UStaticMeshComponent* FHologramHelpers::CreateAttachmentPointRepresentation(const  FFGAttachmentPoint* attachmentPoint, const  AFGBuildable* buildable){ return nullptr; }
void FHologramHelpers::ApplyClearanceExtentShrink( UFGClearanceComponent* clearanceComponent){ }
float FHologramHelpers::CalcPoleHeight(const  FHitResult& aimResult, const  FVector& poleLocation){ return float(); }
float FHologramHelpers::CalcPoleHeightAndHorisontalOffset(float& out_horisontalOffset, const  FHitResult& aimResult, const  FVector& poleLocation){ return float(); }
float FHologramHelpers::FindRightAngleBetweenLocations(const FVector& location, const FVector& targetLocation, const FVector& direction){ return float(); }
void FSplineUtils::FSplineSegmentPointData::InitializePoints(FVector startPos, FVector startForward, FVector startRight, FVector endPos, FVector endForward, FVector endRight, float startRadius, float endRadius){ }
void FSplineUtils::FSplineSegmentPointData::AssignDebugObject( AActor* debugActor){ }
void FSplineUtils::FSplineSegmentPointData::CalculateValues(float forceVerticalExceeding){ }
void FSplineUtils::FSplineSegmentPointData::AddSegmentsToBuilder( FSplineBuilder& builder){ }
void FSplineUtils::CalcAutoCurveSpline( FSplinePointData& startPoint,  FSplinePointData& endPoint){ }
float FSplineUtils::CalcTangentRatioAtSplit(const  USplineComponent* component, float split){ return float(); }
bool FSplineUtils::BuildStraightSpline2D( FSplineBuilder& builder,
		const FVector& endPos,
		const FVector& endForward,
		float dotTreshold){ return bool(); }
bool FSplineUtils::BuildStraightSpline3D( FSplineBuilder& builder,
		const FVector& endPos,
		const FVector& endForward,
		float dotTreshold){ return bool(); }
bool FSplineUtils::BuildTangentBasedSpline3D( FSplineBuilder& builder,
		const FVector& endPos,
		const FVector& endForward,
		float tangetStrength, UWorld* debugWorld , FVector debugACtorLocation){ return bool(); }
bool FSplineUtils::BuildBendStraightBendSpline3D( FSplineBuilder& builder,
		float startRadius,
		float endRadius,
		const FVector& endPos,
		const FVector& endForward, UWorld* debugWorld , FVector debugACtorLocation){ return bool(); }
bool FSplineUtils::BuildBendStraightBendSpline2D( FSplineBuilder& builder,
		float startRadius,
		float endRadius,
		const FVector& endPos,
		const FVector& endForward){ return bool(); }
bool FSplineUtils::BuildBendHorizontalBendVerticalBendDefinedSpline( FSplineBuilder& builder,
		float startRadius,
		float internalRadii,
		float endRadius,
		const FVector& endPos,
		const FVector& endForward,
		bool horizontalFirst ,
		AActor* debugActor){ return bool(); }
bool FSplineUtils::BuildPathDataDefinedSpline( FSplineBuilder& builder,
		TArray<  FHologramAStarNode >& pathNodes,
		float internalRadii,
		const FVector& startNormal,
		const FVector& endNormal,
		AActor* owner){ return bool(); }
bool FSplineUtils::BuildCurveSpline( FSplineBuilder& builder,
		float minTurnRadius,
		const FVector& endPos,
		FVector endForward){ return bool(); }
float FSplineUtils::CalcStraightTangentMagnitude(const FVector& startPos, const FVector& endPos, float targetTangetFactor){ return float(); }
void FSplineUtils::CalcBendDirections3D(const FVector& startPos,
		const FVector& startForward,
		float startRadius,
		const FVector& endPos,
		const FVector& endForward,
		float endRadius,
		bool& out_isStartCW,
		bool& out_isEndCW){ }
void FSplineUtils::CalcBendDirections2D(const FVector& startPos,
		const FVector& startForward,
		float startRadius,
		const FVector& endPos,
		const FVector& endForward,
		float endRadius,
		bool& out_isStartCW,
		bool& out_isEndCW){ }
void FSplineUtils::CalcBendAngles3D(const FVector& startPos,
		const FVector& startForward,
		float startRadius,
		bool isStartCW,
		const FVector& endPos,
		const FVector& endForward,
		float endRadius,
		bool isEndCW,
		float& out_startAngle,
		float& out_endAngle){ }
void FSplineUtils::CalcBendAngles2D(const FVector& startPos,
		const FVector& startForward,
		float startRadius,
		bool isStartCW,
		const FVector& endPos,
		const FVector& endForward,
		float endRadius,
		bool isEndCW,
		float& out_startAngle,
		float& out_endAngle){ }
void FSplineBuilder::Start(const FVector& pos, const FVector& tan){ }
void FSplineBuilder::AddSegment(const FVector& pos, const FVector& tan){ }
void FSplineBuilder::InsertSegmentAfterIndex(const FVector& pos, const FVector& tan, int32 index){ }
void FSplineBuilder::ModifySegment(const FVector& pos, const FVector& tan){ }
void FSplineBuilder::ModifySegment(const FVector& pos, const FVector& tan, int32 index){ }
bool FSplineBuilder::IsValidIndex(int32 index){ return bool(); }
void FSplineBuilder::RemoveSegment(int32 index){ }
FHologramPathingPoint::FHologramPathingPoint(){ }
FHologramPathingPoint::FHologramPathingPoint(FVector worldLocation, FVector gridIndex,  FHologramPathingGrid* grid){ }
FHologramPathingGrid::FHologramPathingGrid(){ }
FHologramPathingGrid::FHologramPathingGrid(const FVector& startForward, const FVector& startRight, const FVector& startLocation, const FVector& endLocation, int32 gridCellSize,  AFGHologram* hologramOwner){ }
void FHologramPathingGrid::InitializeGridPoints(){ }
EHologramGraphAStarResult FHologramPathingGrid::GetHologramPath(const FVector& startLocation, const FVector& endLocation, const FVector& endNormal, TArray<  FHologramAStarNode >& out_pathNodes){ return EHologramGraphAStarResult(); }
void FHologramPathingGrid::CalculateGridNodeCollision(){ }
FVector FHologramPathingGrid::GetWorldSpaceOfGridIndex(const FVector& gridIndex){ return FVector(); }
FHologramPathingPoint& FHologramPathingGrid::GetPathPointForWorldLocation(const FVector& worldLocation){ return *(new FHologramPathingPoint); }
bool FHologramPathingGrid::IsValidGridIndex(const FVector& index){ return bool(); }
bool FHologramPathingGrid::CanConstructGridFrom(const FVector& locationOne, const FVector& locationTwo, const FVector& forwardOne, const FVector& forwardTwo){ return bool(); }
FHologramAStarNode::FHologramAStarNode(){ }
FHologramAStarNode::FHologramAStarNode(int32 unused){ }
FHologramAStarNode::FHologramAStarNode(FHologramPathingPoint* pathingPoint){ }
FHologramAStarNode::FHologramAStarNode(const FHologramAStarNode& pathingNode){ }
int32 FHolgramAStarHelper::GetNeighbourCount(const FHologramAStarNode& nodeRef) const{ return int32(); }
bool FHolgramAStarHelper::IsValidRef(const FHologramAStarNode& nodeRef) const{ return bool(); }
FHologramAStarNode FHolgramAStarHelper::GetNeighbour(const FHologramAStarNode& nodeRef, const int32 neighbourIndex) const {
  return FHologramAStarNode(0);
}
FVector FHolgramAStarHelper::GetDirectionNormal(const FHologramAStarNode& nodeA, const FHologramAStarNode& nodeB) const{ return FVector(); }
FHologramAStarFilter::FHologramAStarFilter(){ }
float FHologramAStarFilter::GetHeuristicScale() const{ return float(); }
float FHologramAStarFilter::GetHeuristicCost(const FHologramAStarNode& startNodeRef, const FHologramAStarNode& endNodeRef) const{ return float(); }
float FHologramAStarFilter::GetDirectionChangeCost(const FVector& parentNormal, const FVector& establishedNormal, const FVector& consideredNormal) const{ return float(); }
float FHologramAStarFilter::GetTraversalCost(const FHologramAStarNode& startNodeRef, const FHologramAStarNode& endNodeRef) const{ return float(); }
bool FHologramAStarFilter::IsTraversalAllowed(const FHologramAStarNode& nodeA, const FHologramAStarNode& nodeB) const{ return bool(); }
bool FHologramAStarFilter::WantsPartialSolution() const{ return bool(); }
