// This file has been automatically generated by the Unreal Header Implementation tool

#include "Hologram/FGHologram.h"
#include "AkAudio/Classes/AkComponent.h"
#include "Components/SceneComponent.h"

AFGHologram::AFGHologram() : Super() {
	this->mRecipe = nullptr;
	this->mLoopSound = CreateDefaultSubobject<UAkComponent>(TEXT("LoopSound"));
	this->mClearanceBox = nullptr;
	this->mClearanceMeshComponent = nullptr;
	this->mClearanceDetector = nullptr;
	this->mShouldCreateClearanceMeshVisual = true;
	this->mSoftClearanceOverlapResponse = EHologramSoftClearanceResponse::HSCR_Default;
	this->mBuildModeCategory = EHologramBuildModeCategory::HBMC_ActorClass;
	this->mDefaultBuildMode = nullptr;
	this->mCurrentBuildMode = nullptr;
	this->mPlacementMaterialState = EHologramMaterialState::HMS_OK;
	this->mValidPlacementMaterial = nullptr;
	this->mInvalidPlacementMaterial = nullptr;
	this->mBuildClass = nullptr;
	this->mUseBuildClearanceOverlapSnapp = false;
	this->mConstructionInstigator = nullptr;
	this->mIsDisabled = false;
	this->mIsChanged = false;
	this->mInitialScrollModeValue = 0;
	this->mConstructionPosition.X = 0.0;
	this->mConstructionPosition.Y = 0.0;
	this->mConstructionPosition.Z = 0.0;
	this->mConstructionRotation.Pitch = 0.0;
	this->mConstructionRotation.Yaw = 0.0;
	this->mConstructionRotation.Roll = 0.0;
	this->SetHidden(true);
	this->bReplicates = true;
	this->RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("RootComponent"));
	this->mLoopSound->SetupAttachment(RootComponent);
}
void AFGHologram::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGHologram, mRecipe);
	DOREPLIFETIME(AFGHologram, mPlacementMaterialState);
	DOREPLIFETIME(AFGHologram, mBuildClass);
	DOREPLIFETIME(AFGHologram, mConstructionInstigator);
	DOREPLIFETIME(AFGHologram, mIsChanged);
	DOREPLIFETIME(AFGHologram, mInitialScrollModeValue);
}
bool AFGHologram::IsNetRelevantFor(const AActor* RealViewer, const AActor* ViewTarget, const FVector& SrcLocation) const{ return bool(); }
AFGHologram* AFGHologram::SpawnHologramFromRecipe(TSubclassOf<  UFGRecipe > inRecipe, AActor* hologramOwner, FVector spawnLocation, APawn* hologramInstigator){ return nullptr; }
AFGHologram* AFGHologram::SpawnChildHologramFromRecipe(AFGHologram* parent, TSubclassOf< UFGRecipe > recipe, AActor* hologramOwner, FVector spawnLocation, APawn* hologramInstigator){ return nullptr; }
void AFGHologram::SetRecipe(TSubclassOf<  UFGRecipe > recipe){ }
TSubclassOf< class UFGItemDescriptor > AFGHologram::GetItemDescriptor() const{ return TSubclassOf<class UFGItemDescriptor>(); }
void AFGHologram::SerializeOntoConstructHologramMessage(FConstructHologramMessage& message){ }
void AFGHologram::DeserializeFromConstructHologramMessage(FConstructHologramMessage& message,  AFGBuildGun* buildGun){ }
void AFGHologram::SerializeConstructMessage(FArchive& ar, FNetConstructionID id){ }
void AFGHologram::ClientPreConstructMessageSerialization(){ }
void AFGHologram::ServerPostConstructMessageDeserialization(){ }
void AFGHologram::OnConstructMessagedDeserialized_Implementation(){ }
void AFGHologram::BeginPlay(){ }
void AFGHologram::Destroyed(){ }
void AFGHologram::SetActorHiddenInGame(bool newHidden){ }
bool AFGHologram::IsValidHitResult(const FHitResult& hitResult) const{ return bool(); }
bool AFGHologram::TryUpgrade(const FHitResult& hitResult){ return bool(); }
void AFGHologram::AdjustForGround(FVector& out_adjustedLocation, FRotator& out_adjustedRotation){ }
bool AFGHologram::TrySnapToActor(const FHitResult& hitResult){ return bool(); }
void AFGHologram::SetHologramLocationAndRotation(const FHitResult& hitResult){ }
void AFGHologram::PreHologramPlacement(){ }
void AFGHologram::PostHologramPlacement(){ }
void AFGHologram::OnInvalidHitResult(){ }
void AFGHologram::ValidatePlacementAndCost( UFGInventoryComponent* inventory){ }
bool AFGHologram::DoMultiStepPlacement(bool isInputFromARelease){ return bool(); }
void AFGHologram::Scroll(int32 delta){ }
void AFGHologram::ScrollRotate(int32 delta, int32 step){ }
void AFGHologram::SetInitialScrollValue(EHologramScrollMode scrollMode, int32 scrollValue){ }
int32 AFGHologram::GetScrollValue(EHologramScrollMode scrollMode) const{ return int32(); }
void AFGHologram::SetScrollMode(EHologramScrollMode mode){ }
EHologramScrollMode AFGHologram::GetScrollMode() const{ return EHologramScrollMode(); }
bool AFGHologram::IsScrollModeSupported(EHologramScrollMode mode) const{ return bool(); }
void AFGHologram::GetSupportedScrollModes(TArray< EHologramScrollMode >* out_modes) const{ }
void AFGHologram::GetSupportedBuildModes_Implementation(TArray< TSubclassOf<UFGHologramBuildModeDescriptor> >& out_buildmodes) const{ }
TSubclassOf<UFGHologramBuildModeDescriptor> AFGHologram::GetCurrentBuildMode(){ return TSubclassOf<UFGHologramBuildModeDescriptor>(); }
void AFGHologram::SetBuildMode(TSubclassOf<UFGHologramBuildModeDescriptor> mode){ }
void AFGHologram::CycleBuildMode(int32 deltaIndex){ }
bool AFGHologram::IsCurrentBuildMode(TSubclassOf<UFGHologramBuildModeDescriptor> buildMode) const{ return bool(); }
void AFGHologram::OnBuildModeChanged(){ }
void AFGHologram::SetSnapToGuideLines(bool isEnabled){ }
void AFGHologram::SetPlacementMaterialState(EHologramMaterialState materialState){ }
EHologramMaterialState AFGHologram::GetHologramMaterialState() const{ return EHologramMaterialState(); }
bool AFGHologram::IsChanged() const{ return bool(); }
AActor* AFGHologram::GetUpgradedActor() const{ return nullptr; }
bool AFGHologram::CanConstruct() const{ return bool(); }
bool AFGHologram::CanTakeNextBuildStep() const{ return bool(); }
AActor* AFGHologram::Construct(TArray< AActor* >& out_children, FNetConstructionID constructionID){ return nullptr; }
void AFGHologram::OnPendingConstructionHologramCreated_Implementation( AFGHologram* fromHologram){ }
void AFGHologram::OnHologramTimeout(){ }
TArray< FItemAmount > AFGHologram::GetBaseCost() const{ return TArray<FItemAmount>(); }
int32 AFGHologram::GetBaseCostMultiplier() const{ return int32(); }
TArray< FItemAmount > AFGHologram::GetCost(bool includeChildren) const{ return TArray<FItemAmount>(); }
void AFGHologram::GetIgnoredClearanceActors(TArray< AActor* >& ignoredActors) const{ }
void AFGHologram::SetDisabled(bool disabled){ }
bool AFGHologram::IsDisabled() const{ return bool(); }
void AFGHologram::SpawnChildren(AActor* hologramOwner, FVector spawnLocation, APawn* hologramInstigator){ }
void AFGHologram::AddChild(AFGHologram* child){ }
void AFGHologram::AddConstructDisqualifier(TSubclassOf<  UFGConstructDisqualifier > disqualifier){ }
void AFGHologram::GetConstructDisqualifiers(TArray< TSubclassOf<  UFGConstructDisqualifier > >& out_constructResults) const{ }
void AFGHologram::ResetConstructDisqualifiers(){ }
void AFGHologram::UpdateRotationValuesFromTransform(){ }
void AFGHologram::SetBuildClass(TSubclassOf<  AActor > buildClass){ }
TSubclassOf< AActor > AFGHologram::GetActorClass() const{ return TSubclassOf<AActor>(); }
void AFGHologram::OnHologramTransformUpdated(){ }
void AFGHologram::SetupClearance( UFGClearanceComponent* clearanceComponent){ }
void AFGHologram::SetupClearanceDetector( UFGClearanceComponent* clearanceComponent){ }
void AFGHologram::CheckClearance(const FVector& locationOffset){ }
void AFGHologram::HandleClearanceOverlap(const FOverlapResult& overlap, const FVector& locationOffset, bool HologramHasSoftClearance){ }
UPrimitiveComponent* AFGHologram::GetClearanceOverlapCheckComponent() const{ return nullptr; }
void AFGHologram::CheckValidPlacement(){ }
void AFGHologram::CheckCanAfford( UFGInventoryComponent* inventory){ }
void AFGHologram::OnSnap(){ }
void AFGHologram::OnRep_PlacementMaterialState(){ }
void AFGHologram::SetMaterial( UMaterialInterface* material){ }
void AFGHologram::SetMaterialState(EHologramMaterialState state){ }
uint8 AFGHologram::GetStencilForHologramMaterialState(EHologramMaterialState state) const{ return uint8(); }
USceneComponent* AFGHologram::SetupComponent(USceneComponent* attachParent, UActorComponent* componentTemplate, const FName& componentName){ return nullptr; }
void AFGHologram::SetIsChanged(bool isChanged){ }
bool AFGHologram::IsLocalHologram() const{ return bool(); }
bool AFGHologram::IsValidHitActor(AActor* hitActor) const{ return bool(); }
int32 AFGHologram::GetRotationStep() const{ return int32(); }
float AFGHologram::ApplyScrollRotationTo(float base, bool onlyUseBaseForAlignment) const{ return float(); }
void AFGHologram::SetupComponents(){ }
void AFGHologram::Client_PlaySnapSound_Implementation(){ }
void AFGHologram::OnRep_InitialScrollModeValue(){ }
const FName AFGHologram::HOLOGRAM_MESH_TAG = FName();
