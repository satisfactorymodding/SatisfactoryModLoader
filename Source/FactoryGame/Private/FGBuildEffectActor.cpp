// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGBuildEffectActor.h"
#include "Components/SceneComponent.h"
#include "Components/StaticMeshComponent.h"
#include "ItemAmount.h"

AFGBuildEffectActor::AFGBuildEffectActor() : Super() {
	this->mDecalMaterial = nullptr;
	this->mDecalBuildEffectMaterial = nullptr;
	this->mMaskedColorDecalMaterial = nullptr;
	this->mMaskedColorDecalEffectMaterial = nullptr;
	this->mBuildEffectFallback = nullptr;
	this->mCurrentMaterializeAmount = 0.0;
	this->mMaterializeAmountPerThrow = 0.0;
	this->mEndStageSpeed = 1.0;
	this->mOffsetCurve.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mOffsetCurve.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mOffsetCurve.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mOffsetCurve.ExternalCurve = nullptr;
	this->mVolumeCurve.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mVolumeCurve.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mVolumeCurve.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mVolumeCurve.ExternalCurve = nullptr;
	this->mGlowCurve.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mGlowCurve.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mGlowCurve.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mGlowCurve.ExternalCurve = nullptr;
	this->mFadeCurve.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mFadeCurve.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mFadeCurve.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mFadeCurve.ExternalCurve = nullptr;
	this->mShouldDelayBelts = true;
	this->splineBuildEffectSpeed = 0.0;
	this->mSplineDelayOffset = -0.2;
	this->mThumbSoundPlayTime = 1.0;
	this->mBounds = FBox(FVector::ZeroVector, FVector::ZeroVector);
	this->mActorBounds = FBox(FVector::ZeroVector, FVector::ZeroVector);
	this->mSlicePlane = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Slice plane"));
	this->mIsBlueprint = false;
	this->PrimaryActorTick.TickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.EndTickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.bTickEvenWhenPaused = false;
	this->PrimaryActorTick.bCanEverTick = true;
	this->PrimaryActorTick.bStartWithTickEnabled = false;
	this->PrimaryActorTick.bAllowTickOnDedicatedServer = true;
	this->PrimaryActorTick.TickInterval = 0.0;
	this->RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));
	this->mSlicePlane->SetupAttachment(RootComponent);
}
void AFGBuildEffectActor::Tick(float DeltaTime){ Super::Tick(DeltaTime); }
void AFGBuildEffectActor::BeginPlay(){ Super::BeginPlay(); }
void AFGBuildEffectActor::EndPlay(const EEndPlayReason::Type endPlayReason){ Super::EndPlay(endPlayReason); }
void AFGBuildEffectActor::SetDismantle(bool State){ }
void AFGBuildEffectActor::AddAbstractDataEntry(TSubclassOf< AFGBuildable > buildableClass, const FRuntimeBuildableInstanceData& runtimeData, UAbstractInstanceDataObject* InstanceData, int32 Index){ }
void AFGBuildEffectActor::RemoveAbstractDataEntry(TSubclassOf< AFGBuildable > buildableClass, int32 index){ }
void AFGBuildEffectActor::SetRecipe(TSubclassOf<UFGRecipe> inRecipe, AFGBuildable* buildable){ }
FBuildEffectEnded& AFGBuildEffectActor::GetBind(UClass* actorClass){ return *(new FBuildEffectEnded); }
void AFGBuildEffectActor::Start(){ }
void AFGBuildEffectActor::Stop(){ }
void AFGBuildEffectActor::CreateVisuals(){ }
void AFGBuildEffectActor::ResolveMaterial(UMeshComponent* Mesh, const TArray<UMaterialInterface*>& Overrides){ }
void AFGBuildEffectActor::SetupThrowQueue(){ }
float AFGBuildEffectActor::GetTotalSplineLength() const{ return float(); }
void AFGBuildEffectActor::TryPlayThumbSound(){ }
FTransform AFGBuildEffectActor::GetTransformOnSplines(bool bWorldSpace) const{ return FTransform(); }
void AFGBuildEffectActor::UpdateCostQueue(){ }
void AFGBuildEffectActor::OnCostActorReachedTarget(){ }
void AFGBuildEffectActor::CleanupRemovedBuildables(){ }
void AFGBuildEffectActor::UpdateSplineBuildables(float Dt){ }
void AFGBuildEffectActor::UpdateGenericBuildables(float Dt){ }
void AFGBuildEffectActor::UpdateWires(){ }
void AFGBuildEffectActor::CalculateBuildEffectBounds(){ }
TArray<USplineComponent*> AFGBuildEffectActor::GetBeltSourceSplinesOrdered(const TArray<class AFGBuildableConveyorBelt*>& inBelts, TArray<AActor*>& orderedActors) const{ return TArray<USplineComponent*>(); }
TArray<USplineComponent*> AFGBuildEffectActor::GetPipeSourceSplineOrdered(const TArray<class AFGBuildablePipeBase*>& inPipes, TArray<AActor*>& orderedActors) const{ return TArray<USplineComponent*>(); }
