// This file has been automatically generated by the Unreal Header Implementation tool

#include "Environment/FGRiver.h"
#include "Components/SplineComponent.h"

#if WITH_EDITORONLY_DATA
void AFGRiver::OnSelected(UObject* Object){ }
void AFGRiver::ReDraw(){ }
void AFGRiver::DrawDebugData(){ }
void AFGRiver::StopDrawDebugData(){ }
void AFGRiver::Destroyed(){ Super::Destroyed(); }
void AFGRiver::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent){ Super::PostEditChangeProperty(PropertyChangedEvent); }
#endif 
#if WITH_EDITOR
void AFGRiver::UpdateFlowIntensity(){ }
void AFGRiver::PopulateMaterialSettings(){ }
void AFGRiver::BuildRiverFromData(const UObject* WorldContext, TSubclassOf<AFGRiver> BaseClass, TArray<FVector> WorldLocations, TArray<FVector> PointScales, TArray<FRotator> PointRotations, TArray<FVector> ArriaveTangets, TArray<FVector> LeaveTangents){ }
void AFGRiver::UpdateRiverFromData(AFGRiver* River, USplineComponent* SourceSpline){ }
void AFGRiver::BuildRiverFromSplineMeshActor(const AActor* SourceActor,TSubclassOf<AFGRiver> RiverClass, bool bAutoResample , float WidthUpscale){ }
void AFGRiver::ResampleSpline(){ }
#endif 
AFGRiver::AFGRiver() : Super() {
	this->mSplineComponent = CreateDefaultSubobject<USplineComponent>(TEXT("RiverSpline"));
	this->mSplineMesh = nullptr;
	this->mSegmentLengthMultiplier = 1.0;
	this->mVolumePrecision = 1000.0;
	this->mVolumeHeightOffset = 0.0;
	this->mDefaultFlowRate = 0.0;
	this->mBaseMaterial = nullptr;
	this->BuoyancyScale = FVector2D::ZeroVector;
	this->BuoyancyMaxIntensity = 0.0;
	this->mDataCollection = nullptr;
	this->bFadeIn = false;
	this->bSideFadeIn = false;
	this->bFadeOut = false;
	this->bSideFadeOut = false;
	this->PrimaryActorTick.TickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.EndTickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.bTickEvenWhenPaused = false;
	this->PrimaryActorTick.bCanEverTick = true;
	this->PrimaryActorTick.bStartWithTickEnabled = true;
	this->PrimaryActorTick.bAllowTickOnDedicatedServer = true;
	this->PrimaryActorTick.TickInterval = 0.0;
	this->RootComponent = mSplineComponent;
}
void AFGRiver::BeginPlay(){ Super::BeginPlay(); }
void AFGRiver::EndPlay(const EEndPlayReason::Type endPlayReason){ Super::EndPlay(endPlayReason); }
void AFGRiver::OnConstruction(const FTransform & Transform){ }
void AFGRiver::FixupSplinePoints(){ }
void AFGRiver::ConstructMesh(){ }
void AFGRiver::ConstructVolumes(){ }
void AFGRiver::SetupMaterialValues(UMaterialInstanceDynamic* Material){ }
void AFGRiver::ApplyVertexColors(TArray<USplineMeshComponent*>& MeshComponents){ }
void AFGRiver::HandlePush(float DeltaTime, ACharacter* Actor){ }
void AFGRiver::Tick(float DeltaTime){ Super::Tick(DeltaTime); }
void AFGRiver::OnBoxBeginOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult){ }
