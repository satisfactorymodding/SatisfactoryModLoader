// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGVehicleSubsystem.h"
#include "Net/UnrealNetwork.h"

AFGSavedWheeledVehiclePath::AFGSavedWheeledVehiclePath() : Super() {
	this->mPathName = TEXT("");
	this->mOriginalVehicleType = nullptr;
	this->mTargetList = nullptr;
	this->mIsInUse = false;
	this->mDistanceFromVehicle = 0.0;
	this->mIsInUseByThisVehicle = false;
	this->mFuelConsumptionPerTrip = 0.0;
	this->mFuelType = nullptr;
	this->bAlwaysRelevant = true;
	this->bReplicates = true;
}
void AFGSavedWheeledVehiclePath::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGSavedWheeledVehiclePath::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGSavedWheeledVehiclePath, mPathName);
	DOREPLIFETIME(AFGSavedWheeledVehiclePath, mTargetList);
	DOREPLIFETIME(AFGSavedWheeledVehiclePath, mUserCount);
	DOREPLIFETIME(AFGSavedWheeledVehiclePath, mIsInUse);
}
#if DEBUG_SELF_DRIVING
int AFGVehicleSubsystem::GetDebugLevel(){ return int(); }
void AFGVehicleSubsystem::SetDebugLevel(int level){ }
int AFGVehicleSubsystem::GetDebugTextLevel(){ return int(); }
void AFGVehicleSubsystem::SetDebugTextLevel(int level){ }
int AFGVehicleSubsystem::GetVehicleDeadlocksDebug(){ return int(); }
void AFGVehicleSubsystem::SetVehicleDeadlocksDebug(int level){ }
#endif 
#if DEBUG_SELF_DRIVING
#endif 
AFGVehicleSubsystem::AFGVehicleSubsystem() : Super() {
	this->mMaxVehicleIterationsPerTick = 10;
	this->mTheChosenWheeledVehicle = nullptr;
	this->PrimaryActorTick.TickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.EndTickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.bTickEvenWhenPaused = false;
	this->PrimaryActorTick.bCanEverTick = true;
	this->PrimaryActorTick.bStartWithTickEnabled = true;
	this->PrimaryActorTick.bAllowTickOnDedicatedServer = true;
	this->PrimaryActorTick.TickInterval = 0.0;
}
void AFGVehicleSubsystem::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGVehicleSubsystem, mWheeledVehicles);
	DOREPLIFETIME(AFGVehicleSubsystem, mSavedPaths);
}
void AFGVehicleSubsystem::BeginPlay(){ Super::BeginPlay(); }
void AFGVehicleSubsystem::EndPlay(const EEndPlayReason::Type endPlayReason){ Super::EndPlay(endPlayReason); }
void AFGVehicleSubsystem::Tick(float dt){ Super::Tick(dt); }
AFGVehicleSubsystem* AFGVehicleSubsystem::Get(UWorld* world){ return nullptr; }
AFGVehicleSubsystem* AFGVehicleSubsystem::Get(UObject* worldContext){ return nullptr; }
void AFGVehicleSubsystem::TickVehicleSimulation(float dt){ }
float AFGVehicleSubsystem::GetEffectiveSimulationDistance( AFGVehicle* vehicle){ return float(); }
float AFGVehicleSubsystem::FindClosestPlayerSq( AFGVehicle* actor) const{ return float(); }
void AFGVehicleSubsystem::AddVehicle( AFGVehicle* vehicle){ }
void AFGVehicleSubsystem::AddWheeledVehicle( AFGWheeledVehicleInfo* vehicle){ }
void AFGVehicleSubsystem::AddDockingStation( AFGBuildableDockingStation* station){ }
void AFGVehicleSubsystem::AddTargetPoint( AFGTargetPoint* target){ }
void AFGVehicleSubsystem::RemoveVehicle( AFGVehicle* vehicle){ }
void AFGVehicleSubsystem::RemoveWheeledVehicle( AFGWheeledVehicleInfo* vehicle){ }
void AFGVehicleSubsystem::RemoveDockingStation( AFGBuildableDockingStation* station){ }
void AFGVehicleSubsystem::RemoveTargetPoint( AFGTargetPoint* targetToRemove, bool updateList){ }
void AFGVehicleSubsystem::InvalidateTargetList(const AFGDrivingTargetList* targetList) const{ }
bool AFGVehicleSubsystem::IsPathNameTaken(const FString& name) const{ return bool(); }
void AFGVehicleSubsystem::SaveWheeledVehiclePath(const FString& saveName,  AFGWheeledVehicleInfo* vehicle){ }
void AFGVehicleSubsystem::UnsaveWheeledVehiclePath(AFGSavedWheeledVehiclePath* path){ }
void AFGVehicleSubsystem::FindSavedWheeledVehiclePaths(const FString& textFilter, TSubclassOf<  AFGWheeledVehicle > typeFilter, const AFGWheeledVehicleInfo* vehicle, TArray< AFGSavedWheeledVehiclePath* >& result){ }
bool AFGVehicleSubsystem::IsWheeledVehiclePathInUse( AFGDrivingTargetList* targetList, const AFGWheeledVehicleInfo* byVehicle) const{ return bool(); }
void AFGVehicleSubsystem::CalculateWheeledVehiclePathStatus( AFGDrivingTargetList* targetList, bool& isSaved, int& userCount) const{ }
int AFGVehicleSubsystem::CalculateWheeledVehicleUserCount( AFGDrivingTargetList* targetList) const{ return int(); }
void AFGVehicleSubsystem::FindVehiclesUsingPath(const  AFGDrivingTargetList* targetList, TArray< AFGWheeledVehicleInfo* >& result) const{ }
void AFGVehicleSubsystem::AddTargetList( AFGDrivingTargetList* targetList){ }
void AFGVehicleSubsystem::RemoveTargetList( AFGDrivingTargetList* targetList){ }
float AFGVehicleSubsystem::CalculateStraightDistanceFromPrevious( AFGTargetPoint* targetPoint) const{ return float(); }
void AFGVehicleSubsystem::UpdateTargetLists(){ }
void AFGVehicleSubsystem::UpdateTargetList(AFGDrivingTargetList* targetList){ }
void AFGVehicleSubsystem::UpdateTargetPoints(){ }
bool AFGVehicleSubsystem::TryToBeTheChosenWheeledVehicle( AFGWheeledVehicleInfo* vehicle){ return bool(); }
bool AFGVehicleSubsystem::TryToResolveEasyDeadlock( AFGWheeledVehicleInfo* vehicle){ return bool(); }
void AFGVehicleSubsystem::ResetBeingTheChosenWheeledVehicle(const  AFGWheeledVehicleInfo* oldChosenVehicle, bool moveToHardDeadlocks){ }
void AFGVehicleSubsystem::RemoveDeadlock(int deadlockId){ }
void AFGVehicleSubsystem::ResetAllDeadlocks(){ }
void AFGVehicleSubsystem::JoinDeadlock(int deadlockId,  AFGWheeledVehicleInfo* vehicle){ }
void AFGVehicleSubsystem::AddHardDeadlock(int deadlockId, const WheeledVehicleDeadlock& deadlock){ }
void AFGVehicleSubsystem::SanitizeDeadlocks(){ }
void AFGVehicleSubsystem::DetectDeadlocks(){ }
void AFGVehicleSubsystem::AssignVehicleTargets(){ }
void AFGVehicleSubsystem::RescueLostVehicles(){ }
void AFGVehicleSubsystem::TryRescueVehicle( AFGWheeledVehicleInfo* vehicleInfo){ }
bool AFGVehicleSubsystem::IsVehicleBlockedBySource(const  AFGWheeledVehicleInfo* sourceVehicle, const  AFGWheeledVehicleInfo* blockedVehicle, TSet< const  AFGWheeledVehicleInfo* >& visitedVehicles, TSet<  AFGWheeledVehicleInfo* >& deadlockedVehicles){ return bool(); }
