// This file has been automatically generated by the Unreal Header Implementation tool

#include "Equipment/FGAmmoType.h"
#include "Net/UnrealNetwork.h"

void FAmmoTickFunction::ExecuteTick(float DeltaTime, ELevelTick TickType, ENamedThreads::Type CurrentThread, const FGraphEventRef& MyCompletionGraphEvent){ }
FString FAmmoTickFunction::DiagnosticMessage(){ return FString(); }
#if WITH_EDITOR
void UFGAmmoType::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent){ Super::PostEditChangeProperty(PropertyChangedEvent); }
#endif 
UFGAmmoType::UFGAmmoType() : Super() {
	this->mWeapon = nullptr;
	this->mInstigator = nullptr;
	this->mFiringTransform = FTransform(FQuat::Identity, FVector::ZeroVector, FVector::OneVector);
	this->mFiringDirection = FVector::ZeroVector;
	this->mMaxAmmoEffectiveRange = 5000.0;
	this->mReloadTimeMultiplier = 1.0;
	this->mFireRate = 1.0;
	this->mFiringTransformIgnoresDispersion = false;
	this->mDispersionFireRateMultiplier = 1.0;
	this->mDispersionPerShot = 0.0;
	this->mRestingDispersion = 0.0;
	this->mFiringDispersion = 0.0;
	this->mDispersionRecoveryTime = 1.0;
	this->mHasBeenInitialized = false;
	this->mAmmoTarget = nullptr;
	this->mWeaponDamageMultiplier = 1.0;
	this->mMagazineMesh = nullptr;
	this->mMagazineMeshAnimClass = nullptr;
	this->mFiringNoise = nullptr;
	this->mAmmoDamageFalloff.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mAmmoDamageFalloff.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mAmmoDamageFalloff.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mAmmoDamageFalloff.ExternalCurve = nullptr;
	this->mMuzzleFlashVFX = nullptr;
	this->mMuzzleFlashScale = FVector::OneVector;
	this->mAmmoColor = FLinearColor(1.0, 1.0, 1.0, 1.0);
	this->mAmmoScale = 1.0;
	this->mAmmoTickFunction.TickGroup = ETickingGroup::TG_PrePhysics;
	this->mAmmoTickFunction.EndTickGroup = ETickingGroup::TG_PrePhysics;
	this->mAmmoTickFunction.bTickEvenWhenPaused = false;
	this->mAmmoTickFunction.bCanEverTick = false;
	this->mAmmoTickFunction.bStartWithTickEnabled = false;
	this->mAmmoTickFunction.bAllowTickOnDedicatedServer = true;
	this->mAmmoTickFunction.TickInterval = 0.0;
}
bool UFGAmmoType::ShouldSave_Implementation() const{ return bool(); }
bool UFGAmmoType::IsSupportedForNetworking() const{ return bool(); }
bool UFGAmmoType::CallRemoteFunction (UFunction* Function, void* Parms,  FOutParmRec* OutParms, FFrame* Stack){ return bool(); }
int32 UFGAmmoType::GetFunctionCallspace (UFunction* Function, FFrame* Stack){ return int32(); }
void UFGAmmoType::GetLifetimeReplicatedProps(TArray< FLifetimeProperty > & OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(UFGAmmoType, mWeapon);
	DOREPLIFETIME(UFGAmmoType, mInstigator);
	DOREPLIFETIME(UFGAmmoType, mFiringTransform);
	DOREPLIFETIME(UFGAmmoType, mFiringDirection);
	DOREPLIFETIME(UFGAmmoType, mHasBeenInitialized);
	DOREPLIFETIME(UFGAmmoType, mAmmoTarget);
	DOREPLIFETIME(UFGAmmoType, mWeaponDamageMultiplier);
}
UWorld* UFGAmmoType::GetWorld() const{ return nullptr; }
bool UFGAmmoType::HasAuthority() const{ return bool(); }
void UFGAmmoType::InitializeAmmoType_Implementation(AFGWeapon* Weapon, bool Force){ }
void UFGAmmoType::OnAmmoTypeEjected_Implementation(){ }
void UFGAmmoType::OnWeaponStateChanged(EWeaponState oldState, EWeaponState newState){ }
void UFGAmmoType::OnBeginFire_Implementation(){ }
void UFGAmmoType::OnEndFire_Implementation(){ }
void UFGAmmoType::AmmoTick_Implementation(float DeltaSeconds){ }
void UFGAmmoType::SetAmmoInstigator(APawn* pawn){ }
void UFGAmmoType::SetFiringTransform(const FTransform& firingTransform){ }
void UFGAmmoType::SetFiringDirection(const FVector& firingDirection){ }
void UFGAmmoType::FireAmmunition_Implementation(){ }
void UFGAmmoType::FireSecondary_Implementation(){ }
USkeletalMesh* UFGAmmoType::GetMagazineMeshWithCustomMaterials(){ return nullptr; }
void UFGAmmoType::RegisterTickFunction(bool shouldRegister){ }
