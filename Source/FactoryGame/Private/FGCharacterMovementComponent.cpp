// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGCharacterMovementComponent.h"

#if WITH_EDITOR
bool UFGCharacterMovementComponent::MoveUpdatedComponentImpl(const FVector& Delta, const FQuat& NewRotation, bool bSweep, FHitResult* OutHit, ETeleportType Teleport){ return bool(); }
#endif 
void FFGPendingHyperJunctionInfo::SortOutputConnectionsClockwise(){ }
UFGCharacterMovementComponent::UFGCharacterMovementComponent() : Super() {
	this->mLastJumpTimeStamp = 0.0;
	this->mClimbSpeed = 500.0;
	this->mMaxSprintSpeed = 900.0;
	this->mSprintMinDotResult = 0.75;
	this->mJumpOffLadderVelocity = 300.0;
	this->mFGCharacterOwner = nullptr;
	this->mParachuteSettings = nullptr;
	this->mCachedJetPack = nullptr;
	this->mCachedHookshot = nullptr;
	this->mCachedJumpingStilts = nullptr;
	this->mCachedHoverPack = nullptr;
	this->mCachedSurfedRailroadTrack = nullptr;
	this->mOnLadder = nullptr;
	this->mPendingHyperJunction.mJunction = nullptr;
	this->mPendingHyperJunction.mConnectionEnteredThrough = nullptr;
	this->mPendingHyperJunction.mDistanceToJunction = 0.0;
	this->mPendingHyperJunction.mLastJunctionCheckDistance = 0.0;
	this->mSlideCurve = nullptr;
	this->mSlopeCurve = nullptr;
	this->mMaxSlideAngle = 1.65;
	this->mBaseVelocity = FVector::ZeroVector;
	this->mBoostJumpZMultiplier = 1.5;
	this->mBoostJumpVelocityMultiplier = 1.3;
	this->mBoostJumpVelocityLimit = 3333.3;
	this->mBoostJumpTimeWindow = 0.15;
	this->mEnableVaultPrototype = false;
	this->mVaultSweepDistance = 250.0;
	this->mVaultHeightThreshold = 100.0;
	this->mVaultForwardVelocity = 800.0;
	this->mVaultVerticalVelocity = 500.0;
	this->mLedgeClimbHeightThreshold = 180.0;
	this->mZiplineData.SpeedMultiplier = 0.0;
	this->mZiplineData.Direction = FVector::ZeroVector;
	this->mZiplineData.AttachActor = nullptr;
	this->mZiplineSpeed = 1350.0;
	this->mZiplineSprintSpeed = 10000.0;
	this->mZiplineCorrectionSpeedMultiplier = 10.0;
	this->mZiplineVelocityInterpolationSpeed = 1.0;
	this->mZiplineVelocityInterpolationSprintSpeed = 0.05;
	this->mZiplineSpeedMultiplierUp = -0.6;
	this->mZiplineSpeedMultiplierDown = 1.0;
	this->mZiplineSprintSettingsCutoff = 0.95;
	this->mZiplineContinuousTravelMaxAngle = 60.0;
	this->mVerticalFlyingSpeed = 3000.0;
	this->mVerticalFlyingSprintSpeed = 6000.0;
	this->mMaxFlySprintSpeed = 6000.0;
}
void UFGCharacterMovementComponent::TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction){ }
FNetworkPredictionData_Client* UFGCharacterMovementComponent::GetPredictionData_Client() const{ return nullptr; }
bool UFGCharacterMovementComponent::DoJump(bool isReplayingMoves){ return bool(); }
void UFGCharacterMovementComponent::CalcVelocity(float dt, float friction, bool isFluid, float brakingDeceleration){ }
float UFGCharacterMovementComponent::GetMaxSpeed() const{ return float(); }
void UFGCharacterMovementComponent::StartNewPhysics(float deltaTime, int32 Iterations){ }
void UFGCharacterMovementComponent::SetDefaultMovementMode(){ }
float UFGCharacterMovementComponent::GetMaxJumpZVelocity() const{ return float(); }
bool UFGCharacterMovementComponent::CanCrouchInCurrentState() const{ return bool(); }
void UFGCharacterMovementComponent::SmoothClientPosition(float DeltaSeconds){ }
void UFGCharacterMovementComponent::SmoothCorrection(const FVector& OldLocation, const FQuat& OldRotation, const FVector& NewLocation, const FQuat& NewRotation){ }
float UFGCharacterMovementComponent::ImmersionDepth() const{ return float(); }
float UFGCharacterMovementComponent::BoostAirControl(float DeltaTime, float TickAirControl, const FVector& FallAcceleration){ return float(); }
FRotator UFGCharacterMovementComponent::ComputeOrientToMovementRotation(const FRotator& CurrentRotation, float DeltaTime, FRotator& DeltaRotation) const{ return FRotator(); }
void UFGCharacterMovementComponent::ServerSetHookLocation_Implementation(const FVector& hookLocation){ }
bool UFGCharacterMovementComponent::ServerSetHookLocation_Validate(const FVector& hookLocation){ return bool(); }
void UFGCharacterMovementComponent::SetHookLocation(const FVector& hookLocation){ }
void UFGCharacterMovementComponent::ToggleWantsToSprintAndSetAutoRelease(bool holdToSprint, bool autoReleaseSprint){ }
void UFGCharacterMovementComponent::SetWantsToSprintAndHoldSprint(bool wantsToSprint, bool holdToSprint, bool autoReleaseSprint){ }
bool UFGCharacterMovementComponent::CanGrabLadder(const  UFGLadderComponent* ladder) const{ return bool(); }
void UFGCharacterMovementComponent::StartClimbLadder( UFGLadderComponent* ladder){ }
void UFGCharacterMovementComponent::StopClimbLadder(){ }
void UFGCharacterMovementComponent::JumpOffLadder(){ }
UFGLadderComponent* UFGCharacterMovementComponent::GetOnLadder() const{ return nullptr; }
bool UFGCharacterMovementComponent::EnterPipeHyper( AFGPipeHyperStart* pipe){ return bool(); }
bool UFGCharacterMovementComponent::EnterPipeHyperDirect(UFGPipeConnectionComponentBase* connectionEnteredThrough, const float InitialMinSpeedFactor){ return bool(); }
bool UFGCharacterMovementComponent::EnterPipeHyperInternal(UFGPipeConnectionComponentBase* connectionEnteredThrough, const float initialPipeVelocity, const float initialPipeProgress, const float accumulatedDeltaTime){ return bool(); }
FVector UFGCharacterMovementComponent::GetPipeTravelDirectionWorld() const{ return FVector(); }
FRotator UFGCharacterMovementComponent::GetPipeCharacterTransform(const FVector& cameraForwardAxis) const{ return FRotator(); }
void UFGCharacterMovementComponent::PipeHyperForceExit(const bool bRagdollCharacter){ }
bool UFGCharacterMovementComponent::WantsToSlide() const{ return bool(); }
void UFGCharacterMovementComponent::UpdateSlideStatus(){ }
bool UFGCharacterMovementComponent::AttemptLedgeClimb(){ return bool(); }
void UFGCharacterMovementComponent::OnLedgeClimbFinished(){ }
void UFGCharacterMovementComponent::UpdateZiplineEffects() const{ }
void UFGCharacterMovementComponent::UpdatePendingJunctionInfo(){ }
const USceneComponent* UFGCharacterMovementComponent::GetUpdateComponent() const{ return nullptr; }
float UFGCharacterMovementComponent::GetZiplineSpeed() const{ return float(); }
void UFGCharacterMovementComponent::StopZiplineMovement(const FVector& exitForce){ }
void UFGCharacterMovementComponent::StartZiplineMovement(AActor* ziplineActor, const FVector& point1, const FVector& point2, const FVector& actorForward){ }
void UFGCharacterMovementComponent::UpdateFromCompressedFlags(uint8 flags){ }
void UFGCharacterMovementComponent::OnMovementUpdated(float deltaSeconds, const FVector & oldLocation, const FVector & oldVelocity){ }
void UFGCharacterMovementComponent::OnMovementModeChanged(EMovementMode PreviousMovementMode, uint8 PreviousCustomMode){ }
void UFGCharacterMovementComponent::PhysCustom(float deltaTime, int32 Iterations){ }
void UFGCharacterMovementComponent::ExecuteDeferredCollisionChange(){ }
void UFGCharacterMovementComponent::SetOnLadder( UFGLadderComponent* ladder){ }
void UFGCharacterMovementComponent::PhysFlying(float deltaTime, int32 iterations){ }
void UFGCharacterMovementComponent::Server_LandSafelyFromFlyingState_Implementation(AFGCharacterPlayer* characterPlayer){ }
void UFGCharacterMovementComponent::LandSafelyFromFlyingState(AFGCharacterPlayer* characterPlayer){ }
void UFGCharacterMovementComponent::PhysLadder(const float deltaTime, int32 iterations){ }
void UFGCharacterMovementComponent::PhysPipe(const float deltaTime){ }
void UFGCharacterMovementComponent::PhysZipline(const float deltaTime){ }
void UFGCharacterMovementComponent::PhysHover(const float deltaTime){ }
void UFGCharacterMovementComponent::PhysParachute(const float deltaTime, int32 iterations){ }
void UFGCharacterMovementComponent::PhysCinematic(const float deltaTime, int32 iterations){ }
void UFGCharacterMovementComponent::UpdateJetPack(float deltaSeconds){ }
void UFGCharacterMovementComponent::UpdateHookshot(const float deltaSeconds, const FVector& oldLocation){ }
void UFGCharacterMovementComponent::UpdateSprintStatus(){ }
bool UFGCharacterMovementComponent::CanSprint() const{ return bool(); }
bool UFGCharacterMovementComponent::CanSlide() const{ return bool(); }
bool UFGCharacterMovementComponent::CanStartSlide() const{ return bool(); }
AFGJetPack* UFGCharacterMovementComponent::GetCachedJetPack(){ return nullptr; }
AFGHookshot* UFGCharacterMovementComponent::GetCachedHookshot(){ return nullptr; }
AFGJumpingStilts* UFGCharacterMovementComponent::GetCachedJumpingStilts(){ return nullptr; }
AFGHoverPack* UFGCharacterMovementComponent::GetCachedHoverPack(){ return nullptr; }
void UFGCharacterMovementComponent::TickSlide(const float delta){ }
bool UFGCharacterMovementComponent::StartLedgeClimb(const float duration, const float speed){ return bool(); }
void UFGCharacterMovementComponent::StopLedgeClimb(const bool interrupt){ }
AActor* UFGCharacterMovementComponent::FindClosestPipeHyper(const FVector& worldLocation, const FVector& velocity, float& out_distanceAlongSpline, FFGDynamicStruct& out_pipeData) const{ return nullptr; }
void UFGCharacterMovementComponent::UpdatePipeMovementDataFromCorrectionResult(const FVector& newLocation, const FVector& newVelocity){ }
void FSavedMove_FGMovement::Clear(){ }
uint8 FSavedMove_FGMovement::GetCompressedFlags() const{ return uint8(); }
bool FSavedMove_FGMovement::CanCombineWith(const FSavedMovePtr& newMove, ACharacter* character, float maxDelta) const{ return bool(); }
void FSavedMove_FGMovement::SetMoveFor(ACharacter* character, float inDeltaTime, FVector const& newAccel,  FNetworkPredictionData_Client_Character & clientData){ }
void FSavedMove_FGMovement::PrepMoveFor( ACharacter* character){ }
FNetworkPredictionData_Client_FGMovement::FNetworkPredictionData_Client_FGMovement(const UCharacterMovementComponent& clientMovement) : FNetworkPredictionData_Client_Character(clientMovement) { }
FSavedMovePtr FNetworkPredictionData_Client_FGMovement::AllocateNewMove(){ return FSavedMovePtr(); }
