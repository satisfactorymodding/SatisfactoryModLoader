// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGDropPod.h"
#include "Components/SceneComponent.h"
#include "FGInventoryComponent.h"
#include "FGPowerConnectionComponent.h"
#include "FGPowerInfoComponent.h"
#include "Net/UnrealNetwork.h"
#include "UObject/ObjectSaveContext.h"

#if WITH_EDITOR
void AFGDropPod::PostLoad(){ Super::PostLoad(); }
void AFGDropPod::PreEditChange(FProperty* PropertyAboutToChange){ }
void AFGDropPod::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent){ Super::PostEditChangeProperty(PropertyChangedEvent); }
#endif 
AFGDropPod::AFGDropPod() : Super() {
	this->mSignificanceRange = 15000.0;
	this->mLinkedCrashSiteDebris = nullptr;
	this->mUnlockRewardClass = nullptr;
	this->mUnlockCost.CostType = EFGDropPodUnlockCostType::None;
	this->mUnlockCost.ItemCost.ItemClass = nullptr;
	this->mUnlockCost.PowerConsumption = 0.0;
	this->mInteractWidgetClass = nullptr;
	this->mAllowDismantleWithLoot = false;
	this->mPowerConnectionComponent = CreateDefaultSubobject<UFGPowerConnectionComponent>(TEXT("PowerConnection2"));
	this->mPowerConnectionComponent->SetMobility(EComponentMobility::Movable);
	this->mPowerInfoComponent = CreateDefaultSubobject<UFGPowerInfoComponent>(TEXT("PowerInfo2"));
	this->mInventoryComponent = CreateDefaultSubobject<UFGInventoryComponent>(TEXT("Inventory2"));
	this->mSpawnedDebris = false;
	this->mHasBeenOpened = false;
	this->mHasBeenLooted = false;
	this->RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("RootComponent"));
	this->RootComponent->SetMobility(EComponentMobility::Movable);
	this->mPowerConnectionComponent->SetupAttachment(RootComponent);
}
void AFGDropPod::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGDropPod, mPropertyReplicator);
	DOREPLIFETIME(AFGDropPod, mHasBeenOpened);
	DOREPLIFETIME(AFGDropPod, mHasBeenLooted);
}
void AFGDropPod::BeginPlay(){ Super::BeginPlay(); }
void AFGDropPod::EndPlay(const EEndPlayReason::Type EndPlayReason){ Super::EndPlay(EndPlayReason); }
void AFGDropPod::PreSave(FObjectPreSaveContext SaveContext)
{
	Super::PreSave(SaveContext);
#if WITH_EDITOR
	// Cache scannable data from the world during the cooking process
	// Avoid attempting to cache the data on the CDOs and Archetypes, and objects without a world context
	if (SaveContext.IsCooking() && !HasAnyFlags(RF_ClassDefaultObject | RF_ArchetypeObject) && GetWorld() != nullptr) {
		mDropPodGuid = GetActorGuid();
	}
#endif
}
void AFGDropPod::GainedSignificance_Implementation(){ }
void AFGDropPod::LostSignificance_Implementation(){ }
void AFGDropPod::GetConditionalReplicatedProps(TArray<FFGCondReplicatedProperty>& outProps) const{ }
bool AFGDropPod::IsPropertyRelevantForConnection(UNetConnection* netConnection, const FProperty* property) const{ return bool(); }
void AFGDropPod::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGDropPod::PostSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGDropPod::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGDropPod::RegisterInteractingPlayer_Implementation( AFGCharacterPlayer* player){ }
void AFGDropPod::UnregisterInteractingPlayer_Implementation( AFGCharacterPlayer* player){ }
void AFGDropPod::UpdateUseState_Implementation( AFGCharacterPlayer* byCharacter, const FVector& atLocation,  UPrimitiveComponent* componentHit, FUseState& out_useState){ }
void AFGDropPod::OnUse_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
void AFGDropPod::OnUseStop_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
bool AFGDropPod::IsUseable_Implementation() const{ return bool(); }
void AFGDropPod::StartIsLookedAt_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
FText AFGDropPod::GetLookAtDecription_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state) const{ return FText(); }
void AFGDropPod::StopIsLookedAt_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
bool AFGDropPod::CanDismantle_Implementation() const{ return Super::CanDismantle_Implementation(); }
void AFGDropPod::GetDismantleRefund_Implementation(TArray<FInventoryStack>& out_refund, bool noBuildCostEnabled) const{ Super::GetDismantleRefund_Implementation(out_refund, noBuildCostEnabled); }
void AFGDropPod::Dismantle_Implementation(){ Super::Dismantle_Implementation(); }
void AFGDropPod::GetDismantleDisqualifiers_Implementation(TArray<TSubclassOf<UFGConstructDisqualifier>>& out_dismantleDisqualifiers, const TArray<AActor*>& allSelectedActors) const{ Super::GetDismantleDisqualifiers_Implementation(out_dismantleDisqualifiers, allSelectedActors); }
bool AFGDropPod::HasBeenLooted() const{ return bool(); }
bool AFGDropPod::GetHasPower() const{ return bool(); }
bool AFGDropPod::CanPlayerOpen(const AFGCharacterPlayer* player) const{ return bool(); }
bool AFGDropPod::OpenDropPod(AFGCharacterPlayer* player){ return bool(); }
AFGCrashSiteDebris* AFGDropPod::GetCrashSiteDebrisActor() const{ return nullptr; }
void AFGDropPod::OnInventoryItemRemoved(TSubclassOf< UFGItemDescriptor > itemClass, const int32 numRemoved, UFGInventoryComponent* targetInventory){ }
void AFGDropPod::SpawnDebrisAroundDropPod(){ }
void AFGDropPod::CacheAndDisconnectWires(){ }
void AFGDropPod::ReconnectCachedWires(){ }
void AFGDropPod::ConsumeOpenCost(AFGCharacterPlayer* player) const{ }
int32 AFGDropPod::GetNumInteractingPlayers() const{ return int32(); }
void AFGDropPod::OnRep_HasBeenOpened(){ }
