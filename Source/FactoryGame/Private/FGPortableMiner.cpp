// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGPortableMiner.h"
#include "FGInventoryComponent.h"
#include "Net/UnrealNetwork.h"

void AFGPortableMiner::GetClearanceData_Implementation(TArray< FFGClearanceData >& out_data) const {
	out_data.Add(mClearanceData);
}

void AFGPortableMiner::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGPortableMiner, mExtractResourceNode);
	DOREPLIFETIME(AFGPortableMiner, mCurrentExtractProgress);
	DOREPLIFETIME(AFGPortableMiner, mOwningPlayerState);
	DOREPLIFETIME(AFGPortableMiner, mIsProducing);
}
AFGPortableMiner::AFGPortableMiner() : Super() {
	this->mExtractCycleTime = 1.0;
	this->mExtractResourceNode = nullptr;
	this->mOutputInventory = CreateDefaultSubobject<UFGInventoryComponent>(TEXT("OutputInventory"));
	this->mCurrentExtractProgress = 0.0;
	this->mInteractWidgetClass = nullptr;
	this->mInventorySize = 1;
	this->mOwningPlayerState = nullptr;
	this->mIsProducing = false;
	this->mClearanceData.Type = EClearanceType::CT_Default;
	this->mClearanceData.ClearanceBox = FBox(FVector::ZeroVector, FVector::ZeroVector);
	this->mClearanceData.RelativeTransform = FTransform(FQuat::Identity, FVector::ZeroVector, FVector::OneVector);
	this->mClearanceData.SoftClearanceResponse = ESoftClearanceOverlapResponse::SCOR_Default;
	this->mClearanceData.ExcludeForSnapping = false;
	this->PrimaryActorTick.TickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.EndTickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.bTickEvenWhenPaused = false;
	this->PrimaryActorTick.bCanEverTick = true;
	this->PrimaryActorTick.bStartWithTickEnabled = true;
	this->PrimaryActorTick.bAllowTickOnDedicatedServer = true;
	this->PrimaryActorTick.TickInterval = 0.0;
	this->bReplicates = true;
}
void AFGPortableMiner::BeginPlay(){ Super::BeginPlay(); }
void AFGPortableMiner::Tick(float dt){ Super::Tick(dt); }
void AFGPortableMiner::TickProducing(float dt){ }
void AFGPortableMiner::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGPortableMiner::PostSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGPortableMiner::PreLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGPortableMiner::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGPortableMiner::GatherDependencies_Implementation(TArray< UObject* >& out_dependentObjects){ }
bool AFGPortableMiner::NeedTransform_Implementation(){ return bool(); }
bool AFGPortableMiner::ShouldSave_Implementation() const{ return bool(); }
void AFGPortableMiner::UpdateUseState_Implementation( AFGCharacterPlayer* byCharacter, const FVector& atLocation,  UPrimitiveComponent* componentHit, FUseState& out_useState){ }
void AFGPortableMiner::OnUse_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
void AFGPortableMiner::OnUseStop_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
bool AFGPortableMiner::IsUseable_Implementation() const{ return bool(); }
void AFGPortableMiner::StartIsLookedAt_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
FText AFGPortableMiner::GetLookAtDecription_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state) const{ return FText(); }
void AFGPortableMiner::StopIsLookedAt_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
bool AFGPortableMiner::IsProducing() const{ return bool(); }
bool AFGPortableMiner::CanProduce() const{ return bool(); }
void AFGPortableMiner::StartProducing(){ }
void AFGPortableMiner::StopProducing(){ }
TArray< FInventoryStack > AFGPortableMiner::GetDismantleInventoryReturns() const{ return TArray<FInventoryStack>(); }
void AFGPortableMiner::SetOwningPlayerState( AFGPlayerState* playerState){ }
void AFGPortableMiner::OnRep_IsProducing(){ }
void AFGPortableMiner::OnRep_OwningPlayerState( AFGPlayerState* previousPlayerState){ }
void AFGPortableMiner::OnPlayerCustomizationDataChanged(const  FPlayerCustomizationData& newCustomizationData){ }
void AFGPortableMiner::UpdateCustomizationData(){ }
