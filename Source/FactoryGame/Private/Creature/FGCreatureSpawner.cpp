// This file has been automatically generated by the Unreal Header Implementation tool

#include "Creature/FGCreatureSpawner.h"
#include "Components/CapsuleComponent.h"

#if WITH_EDITOR
void AFGCreatureSpawner::PostEditMove(bool bFinished){ }
#endif 
AFGCreatureSpawner::AFGCreatureSpawner() : Super() {
	this->mDebugComponent = nullptr;
	this->mEditorSprite = nullptr;
	this->mCapsuleComponent = CreateDefaultSubobject<UCapsuleComponent>(TEXT("CollisionCapsule"));
	this->mCreatureClass = nullptr;
	this->mNumberOfCreatures.Min = 1;
	this->mNumberOfCreatures.Max = 1;
	this->mSpawnRadius = 200.0;
	this->mSpawnHalfHeight = 300.0;
	this->mIsActive = false;
	this->mCachedIsNearBase = false;
	this->mSpawnerDistance = -1.0;
	this->mIsPendingDestroy = false;
	this->mIsPendingSpawn = false;
	this->mCurrentCreatureToSpawnIndex = -1;
	this->mIsMonsterCloset = false;
	this->mMonsterClosetSpawnDelay = 2.0;
	this->mSpawnDistanceOverride = -1.0;
	this->mRandomSeed = -1;
	this->mVisualizeSpawnDistance = false;
	this->mRespawnTimeIndays = 3;
	this->bCollideWhenPlacing = true;
	this->SpawnCollisionHandlingMethod = ESpawnActorCollisionHandlingMethod::AdjustIfPossibleButDontSpawnIfColliding;
	this->RootComponent = mCapsuleComponent;
}
void AFGCreatureSpawner::BeginPlay(){ }
void AFGCreatureSpawner::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGCreatureSpawner::PostSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGCreatureSpawner::PreLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGCreatureSpawner::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGCreatureSpawner::GatherDependencies_Implementation(TArray< UObject* >& out_dependentObjects){ }
bool AFGCreatureSpawner::NeedTransform_Implementation(){ return bool(); }
bool AFGCreatureSpawner::ShouldSave_Implementation() const{ return bool(); }
void AFGCreatureSpawner::GetSpawnLocations(TArray<FVector>& out_spawnLocations) const{ }
void AFGCreatureSpawner::SetSpawnerActive(bool active){ }
void AFGCreatureSpawner::SpawnCreatures(){ }
void AFGCreatureSpawner::SpawnSingleCreature(){ }
void AFGCreatureSpawner::DestroyCreatures(){ }
bool AFGCreatureSpawner::ShouldResetKillStatus(FSpawnData spawnData, int32 newDayNr){ return bool(); }
void AFGCreatureSpawner::UpdateKillStatus(int32 newDayNr){ }
bool AFGCreatureSpawner::IsTimeForCreature(){ return bool(); }
void AFGCreatureSpawner::QuerySpawnConditions(){ }
void AFGCreatureSpawner::TrySpawnCreatures(){ }
void AFGCreatureSpawner::CreatureDied(AActor* thisActor){ }
bool AFGCreatureSpawner::CalculateSpawningLocations(){ return bool(); }
void AFGCreatureSpawner::AddCreature( AFGCreature* newCreature){ }
float AFGCreatureSpawner::GetSpawnerWeight(){ return float(); }
void AFGCreatureSpawner::SetupSpawnDistance(){ }
void AFGCreatureSpawner::TryRecoupleCreatureAndSpawner(){ }
bool AFGCreatureSpawner::TryFindNonOverlappingLocation(const TArray<FVector2D>& usedSpawnLocations, float spawnRadius, int32 maxRetries, FVector2D& out_location){ return bool(); }
bool AFGCreatureSpawner::IsLocationNonOverlapping(const FVector2D& location, const TArray< FVector2D >& usedLocations) const{ return bool(); }
void AFGCreatureSpawner::CleanupCreatureList(){ }
void AFGCreatureSpawner::SetupSpawnWeight(){ }
void AFGCreatureSpawner::TryDestroyCreatures(){ }
void AFGCreatureSpawner::ReceiveOnTraceCompleted(const TArray< FOverlapResult > & Results){ }
FTraceHandle AFGCreatureSpawner::RequestTrace(){ return FTraceHandle(); }
void AFGCreatureSpawner::OnTraceCompleted(const FTraceHandle& Handle, FOverlapDatum& Data){ }
