// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGWaterVolume.h"
#include "AI/FGNavArea_Water.h"

#if WITH_EDITOR
void AFGWaterVolume::PostLoad(){ Super::PostLoad(); }
void AFGWaterVolume::PreSave(const  ITargetPlatform* targetPlatform){ }
void AFGWaterVolume::PostEditChangeProperty(FPropertyChangedEvent& propertyChangedEvent){ Super::PostEditChangeProperty(propertyChangedEvent); }
void AFGWaterVolume::CheckForErrors(){ Super::CheckForErrors(); }
#endif 
AFGWaterVolume::AFGWaterVolume() : Super() {
	this->mAreaClass = UFGNavArea_Water::StaticClass();
	this->mCanPlaceExtractor = true;
	this->mResourceClass = FSoftClassPath("/Game/FactoryGame/Resource/RawResources/Water/Desc_Water.Desc_Water_C").TryLoadClass<UObject>();
	this->bWaterVolume = true;
}
void AFGWaterVolume::PostInitProperties(){ Super::PostInitProperties(); }
void AFGWaterVolume::BeginPlay(){ }
void AFGWaterVolume::EndPlay(const EEndPlayReason::Type endPlayReason){ }
bool AFGWaterVolume::IsOverlapInVolume(const  USceneComponent& testComponent) const{ return bool(); }
void AFGWaterVolume::GainedSignificance_Implementation(){ }
void AFGWaterVolume::LostSignificance_Implementation(){ }
void AFGWaterVolume::GainedSignificance_Native(){ }
void AFGWaterVolume::LostSignificance_Native(){ }
float AFGWaterVolume::GetSignificanceRange(){ return float(); }
void AFGWaterVolume::SetCameraIsInside(bool cameraInside, FVector cameraLocation,  AFGPlayerController* PC){ }
const UFGWaterAudio* AFGWaterVolume::GetAudioSettings() const{ return nullptr; }
bool AFGWaterVolume::EncompassesPoint(FVector point, float sphereRadius , float* out_distanceToPoint){ return bool(); }
FPostProcessVolumeProperties AFGWaterVolume::GetProperties() const{ return FPostProcessVolumeProperties(); }
void AFGWaterVolume::PostUnregisterAllComponents(void){ }
void AFGWaterVolume::PostRegisterAllComponents(){ }
void AFGWaterVolume::GetNavigationData(FNavigationRelevantData& Data) const{ }
FBox AFGWaterVolume::GetNavigationBounds() const{ return FBox(); }
void AFGWaterVolume::RebuildNavigationData(){ }
void AFGWaterVolume::SetIsOccupied(bool occupied){ }
bool AFGWaterVolume::IsOccupied() const{ return bool(); }
bool AFGWaterVolume::CanBecomeOccupied() const{ return bool(); }
bool AFGWaterVolume::HasAnyResources() const{ return bool(); }
TSubclassOf<class UFGResourceDescriptor> AFGWaterVolume::GetResourceClass() const{ return TSubclassOf<class UFGResourceDescriptor>(); }
int32 AFGWaterVolume::ExtractResource(int32 amount){ return int32(); }
float AFGWaterVolume::GetExtractionSpeedMultiplier() const{ return float(); }
FVector AFGWaterVolume::GetPlacementLocation(const FVector& hitLocation) const{ return FVector(); }
bool AFGWaterVolume::CanPlaceResourceExtractor() const{ return bool(); }
void AFGWaterVolume::OnPrimitiveComponentEntered(UPrimitiveComponent* overlappedComp, AActor* other, UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool fromSweep, const FHitResult& sweepResult){ }
void AFGWaterVolume::OnPrimitiveComponentExited(UPrimitiveComponent* overlappedComp, AActor* other, UPrimitiveComponent* otherComp, int32 otherBodyIndex){ }
void AFGWaterVolume::OnPawnEntered(APawn* pawn, const FHitResult& enterInfo){ }
void AFGWaterVolume::OnPawnExited(APawn* pawn){ }
