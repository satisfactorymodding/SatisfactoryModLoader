// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGVertexAnimatedMeshComponent.h"

#if WITH_EDITORONLY_DATA
#endif 
void UVertexAnimationNotifySubsystem::Tick(float DeltaTime){ }
void UVertexAnimationNotifySubsystem::TickAnimationRandomization(float DeltaTime){ }
void UVertexAnimationNotifySubsystem::AddRelevantComponents(UFGVertexAnimatedMeshComponent* Mesh){ }
void UVertexAnimationNotifySubsystem::RemoveRelevantComponents(UFGVertexAnimatedMeshComponent* Mesh){ }
void UVertexAnimationNotifySubsystem::AddManagedRandomizedAnimationEntry(UFGVertexAnimatedMeshComponent* Mesh){ }
void UVertexAnimationNotifySubsystem::RemoveManagedRandomizedAnimationEntry(UFGVertexAnimatedMeshComponent* Mesh){ }
void UVertexAnimationNotifySubsystem::DequeueEntries(){ }
bool UVertexAnimationNotifySubsystem::GetPlayerViewpointAndLocation(FVector& OutVector, FRotator& OutRotation) const{ return bool(); }
#if WITH_EDITOR
void UFGVertexAnimatedMeshComponent::PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent){ }
void UFGVertexAnimatedMeshComponent::SampleTimelineDataFromEntry(UAnimSequence* Sequence, TSubclassOf<AFGBuildable> Target, FName ComponentName){ }
#endif 
UFGVertexAnimatedMeshComponent::UFGVertexAnimatedMeshComponent() : Super() {
	this->mSignificanceRange = 6000.0;
	this->mWireMesh = nullptr;
	this->mAnimationAsset = nullptr;
	this->mMaxDrawRangeCable = 5000.0;
	this->mWireMeshTimeAdjustment = 0.0;
	this->TimePrimitiveDataBindID = -1;
	this->TimeSpeedPrimitiveDataBindID = -1;
	this->bAllowWindUpDownInterpolation = false;
	this->mOverClockedAnimationSpeed = 2.0;
	this->mUnderClockedAnimationSpeed = 0.5;
	this->bHasWindDownSequence = false;
	this->bHasWindUpSequence = false;
	this->bHasWire = false;
	this->bHasProducingAnimationVariations = false;
	this->bIsSignificant = false;
	this->mSpawnedWireMeshComponent = nullptr;
	this->mBlockInstancing = true;
	this->WorldPositionOffsetDisableDistance = 100000;
}
void UFGVertexAnimatedMeshComponent::BeginPlay(){ Super::BeginPlay(); }
void UFGVertexAnimatedMeshComponent::EndPlay(const EEndPlayReason::Type endPlayReason){ Super::EndPlay(endPlayReason); }
void UFGVertexAnimatedMeshComponent::GainedSignificance_Implementation(){ }
void UFGVertexAnimatedMeshComponent::LostSignificance_Implementation(){ }
bool UFGVertexAnimatedMeshComponent::ShouldAddToSignificanceManager() const{ return bool(); }
void UFGVertexAnimatedMeshComponent::RandomizeAnimation(){ }
void UFGVertexAnimatedMeshComponent::OnProductionStatusChanged(EProductionStatus NewState){ }
void UFGVertexAnimatedMeshComponent::OnBuildingCurrentPotentialChanged(float NewPotential){ }
void UFGVertexAnimatedMeshComponent::DelayedOverclockingChanged(){ }
void UFGVertexAnimatedMeshComponent::OnOverclockingChanged(EVTXAnimOverclockState NewState, bool IsSignificant){ }
void UFGVertexAnimatedMeshComponent::UpdateEffectTimeline(const float LastTickTime, const float Dist, const float WorldTime){ }
void UFGVertexAnimatedMeshComponent::OnUpdateState(EVTXAnimProductionStatus NewState){ }
void UFGVertexAnimatedMeshComponent::StartProducing(bool bFromFrozenIdle , int32 AnimationSequenceID){ }
void UFGVertexAnimatedMeshComponent::StartWindup(){ }
void UFGVertexAnimatedMeshComponent::StartWindDown(){ }
void UFGVertexAnimatedMeshComponent::StartIdle(){ }
void UFGVertexAnimatedMeshComponent::FreezeAnimation(float ProductionAnimationDuration){ }
void UFGVertexAnimatedMeshComponent::SetupWireMesh(){ }
void UFGVertexAnimatedMeshComponent::KillWireMesh(){ }
void UFGVertexAnimatedMeshComponent::UpdateStateToProducing(){ }
void UFGVertexAnimatedMeshComponent::UpdateStateToIdle(){ }
void UFGVertexAnimatedMeshComponent::StartRandomizedProductionAnimation(){ }
TArray<UMaterialInterface*> UFGVertexAnimatedMeshComponent::GetMaterialsFromState(EVTXAnimProductionStatus State, int32 AnimationSequenceID){ return TArray<UMaterialInterface*>(); }
void UFGVertexAnimatedMeshComponent::UpdateMaterial(TArray<UMaterialInterface*> Materials){ }
#if WITH_EDITOR
#endif 
void UFGNotifyBase::TryFireNotify(const float& Distance, const float& AnimDuration, const float& LastTickTime, UFGVertexAnimatedMeshComponent* Owner,const UFGNotifyBase* Entry, bool bForceSeek){ }
void UFGStaticVFXNotify::Fire(UFGVertexAnimatedMeshComponent* Owner, float CurrentTime , bool bForceSeek) const{ }
void UFGStaticSFXNotify::Fire(UFGVertexAnimatedMeshComponent* Owner, float CurrentTime , bool bForceSeek) const{ }
#if WITH_EDITOR
#endif 
FTransform UFGAnimatedNotifyBase::GetTransformAtTime(float Time) const{ return FTransform(); }
#if WITH_EDITOR
#if WITH_EDITORONLY_DATA
void UFGAnimatedNotifyBase::SetCurveInfoAtTime(float Time, FVector Location, FRotator Rotation){ }
void UFGAnimatedNotifyBase::ResampleCurve(){ }
void UFGAnimatedNotifyBase::Compress(){ }
#endif
#endif
void UFGAnimatedVFXNotify::Fire(UFGVertexAnimatedMeshComponent* Owner, float CurrentTime, bool bForceSeek) const{ }
void UFGAnimatedVFXNotify::Deactivate(UFGVertexAnimatedMeshComponent* Owner) const{ }
void UFGAnimatedSFXNotify::Fire(UFGVertexAnimatedMeshComponent* Owner, float CurrentTime, bool bForceSeek) const{ }
void UFGAnimatedSFXNotify::Deactivate(UFGVertexAnimatedMeshComponent* Owner) const{ }
