// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGGameMode.h"
#include "FGCharacterPlayer.h"
#include "FGGameSessionOnline.h"
#include "FGGameState.h"
#include "FGHUD.h"
#include "FGPlayerState.h"

const TCHAR* AFGGameMode::StartLocationOption = TEXT("startloc");
const TCHAR* AFGGameMode::LoadGameOption = TEXT("loadgame");
const TCHAR* AFGGameMode::SkipOnboarding = TEXT("skiponboarding");
const TCHAR* AFGGameMode::AdvancedGameSettingsOption = TEXT("advancedGameSettings");
const TCHAR* AFGGameMode::EnableAdvancedGameSettingsOption = TEXT("enableAdvancedGameSettings");

UWorld* UFGDedicatedServerGameModeComponentInterface::GetWorld() const{ return nullptr; }
AFGGameMode* UFGDedicatedServerGameModeComponentInterface::GetOwnerGameMode() const{ return nullptr; }
AFGGameMode::AFGGameMode() : Super() {
	this->mSaveSession = nullptr;
	this->mSaveSessionName = TEXT("");
	this->mLastAutoSaveId = 255;
	this->mStartingPointTagName = TEXT("None");
	this->mAllowPossessAny = false;
	this->mDebugStartingPointTagName = TEXT("None");
	this->mIsMainMenu = false;
	this->mDedicatedServerInterface = nullptr;
	this->InactivePlayerStateLifeSpan = 0.0;
	this->GameSessionClass = AFGGameSessionOnline::StaticClass();
	this->GameStateClass = AFGGameState::StaticClass();
	this->PlayerStateClass = AFGPlayerState::StaticClass();
	this->HUDClass = AFGHUD::StaticClass();
	this->DefaultPawnClass = AFGCharacterPlayer::StaticClass();
	this->PrimaryActorTick.TickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.EndTickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.bTickEvenWhenPaused = true;
	this->PrimaryActorTick.bCanEverTick = true;
	this->PrimaryActorTick.bStartWithTickEnabled = true;
	this->PrimaryActorTick.bAllowTickOnDedicatedServer = true;
	this->PrimaryActorTick.TickInterval = 0.0;
}
void AFGGameMode::Serialize(FArchive& ar){ Super::Serialize(ar); }
void AFGGameMode::BeginPlay(){ Super::BeginPlay(); }
void AFGGameMode::Tick(float DeltaSeconds){ Super::Tick(DeltaSeconds); }
void AFGGameMode::EndPlay(const EEndPlayReason::Type endPlayReason){ Super::EndPlay(endPlayReason); }
void AFGGameMode::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGGameMode::PostSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGGameMode::PreLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGGameMode::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGGameMode::GatherDependencies_Implementation(TArray< UObject* >& out_dependentObjects){ }
bool AFGGameMode::NeedTransform_Implementation(){ return bool(); }
bool AFGGameMode::ShouldSave_Implementation() const{ return bool(); }
void AFGGameMode::FinishRestartPlayer(AController* NewPlayer, const FRotator& StartRotation){ }
void AFGGameMode::InitGame(const FString& mapName, const FString& options, FString& out_errorMessage){ }
APawn* AFGGameMode::SpawnDefaultPawnAtTransform_Implementation(AController* newPlayer, const FTransform& spawnTransform){ return nullptr; }
void AFGGameMode::InitGameState(){ }
bool AFGGameMode::AllowCheats(APlayerController* p){ return bool(); }
AActor* AFGGameMode::ChoosePlayerStart_Implementation(AController* player){ return nullptr; }
void AFGGameMode::RestartPlayer(AController* newPlayer){ }
void AFGGameMode::PostLogin(APlayerController* newPlayer){ }
APlayerController* AFGGameMode::Login(UPlayer* NewPlayer, ENetRole InRemoteRole, const FString& Portal, const FString& Options, const FUniqueNetIdRepl& UniqueId, FString& ErrorMessage){ return nullptr; }
void AFGGameMode::Logout(AController* exiting){ }
bool AFGGameMode::FindInactivePlayer(APlayerController* PC){ return bool(); }
void AFGGameMode::GenericPlayerInitialization(AController* C){ }
bool AFGGameMode::IsPaused() const{ return bool(); }
void AFGGameMode::InitStartSpot_Implementation(AActor* StartSpot, AController* NewPlayer){ }
void AFGGameMode::PostActorsInitialized(const UWorld::FActorsInitializedParams& inParams){ }
uint8 AFGGameMode::GenerateNextAutoSaveId(){ return uint8(); }
void AFGGameMode::SetSaveSessionName(const FString& name){ }
bool AFGGameMode::ShouldSetupSave() const{ return bool(); }
bool AFGGameMode::GetDefaultPlayerCapsuleSize(const UWorld* world, float& out_capsuleRadius, float& out_capsuleHalfHeight){ return bool(); }
bool AFGGameMode::RegisterRemoteCallObjectClass(const TSubclassOf< UFGRemoteCallObject > inClass){ return bool(); }
void AFGGameMode::RegisterCallObjectOnAllCurrentPlayers(const TSubclassOf<UFGRemoteCallObject> inClass){ }
void AFGGameMode::RebootSession(){ }
bool AFGGameMode::ShouldSkipOnboarding() const{ return bool(); }
void AFGGameMode::TriggerWorldSave(const FString& saveGameName){ }
void AFGGameMode::TriggerBundledWorldSave(const FString& saveGameName){ }
void AFGGameMode::BuildFoundationsBro(int32 howMany){ }
void AFGGameMode::ShowInviteUI(){ }
void AFGGameMode::PrintSessionId(){ }
bool AFGGameMode::IsValidPawnToReclaim(APawn* pawn) const{ return bool(); }
void AFGGameMode::OnSessionRestartTimeSlotUpdated(FString OptionName, FVariant OptionValue){ }
void AFGGameMode::GetRestartSessionSaveName(FString& out_sessionName) const{ }
void AFGGameMode::BuildRestartSessionURL(const FString& saveName, FString& out_sessionUrl) const{ }
APlayerStart* AFGGameMode::CachePlayerStarts(TMap< FName, TArray< APlayerStart* > >& out_playerStarts){ return nullptr; }
void AFGGameMode::PartitionPlayerStartsByOccupancy(const TArray< APlayerStart* >& playerStarts,
		TSubclassOf< APawn > pawnClassToFit,
		TArray< APlayerStart* >& out_unOccupied,
		TArray< APlayerStart* >& out_occupied) const{ }
void AFGGameMode::DiscoverDefaultRemoteCallObjects(){ }
void AFGGameMode::RecalculateSessionRestartTime(){ }
void AFGGameMode::TickSessionRebootTimer(){ }
FName UFGGameModeStatics::GetStartingAreaNameFromOptions(const TMap<FString, FString> &Options){ return FName(); }
bool UFGGameModeStatics::HasSkipOnboardingOption(const TMap<FString, FString> &Options){ return bool(); }
bool UFGGameModeStatics::HasAdvancedGameSettings(const TMap<FString, FString> &Options){ return bool(); }
