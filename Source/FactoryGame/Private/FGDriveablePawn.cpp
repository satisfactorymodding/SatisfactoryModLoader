// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGDriveablePawn.h"
#include "Net/UnrealNetwork.h"

AFGDriveablePawn::AFGDriveablePawn() : Super() {
	this->mShouldAttachDriver = true;
	this->mIsDriverVisible = false;
	this->mDriverSeatSocket = TEXT("None");
	this->mDriverSeatAnimation = nullptr;
	this->mDriverExitOffset = FVector::ZeroVector;
	this->mIsPossessed = false;
	this->mMappingContext = nullptr;
	this->mSpringArmComponent = nullptr;
	this->mCameraComponent = nullptr;
	this->mLastSafeLocation = FVector::ZeroVector;
	this->mIsInUnsafeLoadLocation = false;
	this->mDriver = nullptr;
	this->mIsDriving = false;
}
void AFGDriveablePawn::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGDriveablePawn, mIsPossessed);
	DOREPLIFETIME(AFGDriveablePawn, mPropertyReplicator);
	DOREPLIFETIME(AFGDriveablePawn, mDriver);
	DOREPLIFETIME(AFGDriveablePawn, mIsDriving);
}
void AFGDriveablePawn::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGDriveablePawn::PostSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGDriveablePawn::PreLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGDriveablePawn::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGDriveablePawn::GatherDependencies_Implementation(TArray< UObject* >& out_dependentObjects){ }
bool AFGDriveablePawn::NeedTransform_Implementation(){ return bool(); }
bool AFGDriveablePawn::ShouldSave_Implementation() const{ return bool(); }
void AFGDriveablePawn::GetConditionalReplicatedProps(TArray<FFGCondReplicatedProperty>& outProps) const{ }
bool AFGDriveablePawn::IsPropertyRelevantForConnection(UNetConnection* netConnection, const FProperty* property) const{ return bool(); }
void AFGDriveablePawn::PossessedBy(AController* newController){ }
void AFGDriveablePawn::UnPossessed(){ }
void AFGDriveablePawn::OnRep_PlayerState(){ }
void AFGDriveablePawn::CalcCamera(float DeltaTime, FMinimalViewInfo& OutResult){ }
void AFGDriveablePawn::PreInitializeComponents(){ Super::PreInitializeComponents(); }
void AFGDriveablePawn::SetIsInUnsafeLoadLocation(bool isUnsafe){ }
void AFGDriveablePawn::SetLastSafeLocation(const FVector& location){ }
FVector AFGDriveablePawn::GetLastSafeLoadLocation(){ return FVector(); }
void AFGDriveablePawn::UpdatePlayerStatus(){ }
bool AFGDriveablePawn::HasActiveDriver() const{ return bool(); }
bool AFGDriveablePawn::CanDriverEnter( AFGCharacterPlayer* character){ return bool(); }
bool AFGDriveablePawn::DriverEnter( AFGCharacterPlayer* driver){ return bool(); }
bool AFGDriveablePawn::DriverLeave(bool keepDriving){ return bool(); }
void AFGDriveablePawn::Server_DriverLeave_Implementation(){ }
bool AFGDriveablePawn::CanLeaveVehicle( AFGCharacterPlayer* character){ return bool(); }
void AFGDriveablePawn::AttachDriver( AFGCharacterPlayer* driver){ }
bool AFGDriveablePawn::GetSafeExitLocation( AFGCharacterPlayer* exitingCharacter, const FVector& exitOffset, FVector& out_location, FRotator& out_rotation) const{ return bool(); }
void AFGDriveablePawn::OnDrivingStatusChanged(){ }
void AFGDriveablePawn::AddInputBindings(UInputComponent* inputComponent){ }
void AFGDriveablePawn::ClearInputBindings( AFGPlayerController* playerController){ }
void AFGDriveablePawn::PlaceExitingDriver(){ }
void AFGDriveablePawn::SetDriving(bool isDriving){ }
void AFGDriveablePawn::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent){ }
void AFGDriveablePawn::Input_LeaveVehicle(const FInputActionValue& actionValue){ }
UFGGameUI* AFGDriveablePawn::GetGameUI() const{ return nullptr; }
void AFGDriveablePawn::OnRep_IsDriving(){ }
void AFGDriveablePawn::OnRep_Driver(AFGCharacterPlayer* previousDriver){ }
void AFGDriveablePawn::ActivateCameraComponents(){ }
void AFGDriveablePawn::DeactivateCameraComponents(){ }
