// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGRecipeManager.h"
#include "Net/UnrealNetwork.h"

void UFGRecipeRCO::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(UFGRecipeRCO, mForceNetField_UFGRecipeRemoteCallObject);
}
void UFGRecipeRCO::Server_RequestAvailableRecipeUpdate_Implementation(const int32& currentIndex){ }
void UFGRecipeRCO::Client_RespondAvailableRecipeUpdate_Implementation(const TArray< TSubclassOf< UFGRecipe > >& recipes){ }
void UFGRecipeRCO::Server_RequestAllRecipeUpdate_Implementation(const int32& currentIndex){ }
void UFGRecipeRCO::Client_RespondAllRecipeUpdate_Implementation(const TArray< TSubclassOf< UFGRecipe > >& recipes){ }
AFGRecipeManager* AFGRecipeManager::Get(UWorld* world){ return nullptr; }
AFGRecipeManager* AFGRecipeManager::Get(UObject* worldContext){ return nullptr; }
void AFGRecipeManager::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGRecipeManager, mNumAvailableRecipes);
	DOREPLIFETIME(AFGRecipeManager, mNumAllRecipes);
	DOREPLIFETIME(AFGRecipeManager, mAvailableCustomizationRecipes);
}
void AFGRecipeManager::BeginPlay(){ Super::BeginPlay(); }
void AFGRecipeManager::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGRecipeManager::PostSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGRecipeManager::PreLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGRecipeManager::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGRecipeManager::GatherDependencies_Implementation(TArray< UObject* >& out_dependentObjects){ }
bool AFGRecipeManager::NeedTransform_Implementation(){ return bool(); }
bool AFGRecipeManager::ShouldSave_Implementation() const{ return bool(); }
void AFGRecipeManager::AddAvailableRecipe(TSubclassOf< UFGRecipe > recipe){ }
void AFGRecipeManager::GetAllAvailableRecipes(TArray< TSubclassOf< UFGRecipe > >& out_recipes){ }
void AFGRecipeManager::GetAllAvailableCustomizationRecipes(TArray< TSubclassOf< UFGCustomizationRecipe > >& out_recipes){ }
TSubclassOf<class UFGCustomizationRecipe> AFGRecipeManager::GetCustomizationRecipeFromDesc(TSubclassOf<class UFGFactoryCustomizationDescriptor> desc){ return TSubclassOf<UFGCustomizationRecipe>(); }
void AFGRecipeManager::GetAvailableRecipesForProducer(TSubclassOf< UObject > forProducer, TArray< TSubclassOf< UFGRecipe > >& out_recipes){ }
void AFGRecipeManager::GetAffordableRecipesForProducer( AFGCharacterPlayer* player, TSubclassOf< UObject > forProducer, TArray< TSubclassOf< UFGRecipe > >& out_recipes){ }
bool AFGRecipeManager::IsRecipeAvailable(TSubclassOf< UFGRecipe > recipeClass) const{ return bool(); }
bool AFGRecipeManager::IsCustomizationRecipeAvailable(TSubclassOf< UFGCustomizationRecipe > recipeClass) const{ return bool(); }
bool AFGRecipeManager::IsBuildingAvailable(const TSubclassOf<  AFGBuildable > buildableClass) const{ return bool(); }
TSubclassOf< UFGBuildingDescriptor > AFGRecipeManager::FindBuildingDescriptorByClass(TSubclassOf< AFGBuildable > buildable) const{ return TSubclassOf<UFGBuildingDescriptor>(); }
TArray< TSubclassOf< UFGRecipe > > AFGRecipeManager::FindRecipesByIngredient(TSubclassOf< UFGItemDescriptor > ingredient, bool onlyAvailableRecipes , bool availableFirst) const{ return TArray<TSubclassOf<UFGRecipe> >(); }
TArray< TSubclassOf< UFGRecipe > > AFGRecipeManager::FindRecipesByProduct(TSubclassOf< UFGItemDescriptor > product, bool onlyAvailableRecipes , bool availableFirst) const{ return TArray<TSubclassOf<UFGRecipe> >(); }
void AFGRecipeManager::ResetAllRecipes(){ }
void AFGRecipeManager::Debug_DumpStateToLog() const{ }
void AFGRecipeManager::NotifyGameStateReadyOnClient(){ }
void AFGRecipeManager::OnSubsystemsValid(){ }
void AFGRecipeManager::FilterRecipesByProducer(const TArray< TSubclassOf< UFGRecipe > >& inRecipes, TSubclassOf< UObject > forProducer, TArray< TSubclassOf< UFGRecipe > >& out_recipes){ }
bool AFGRecipeManager::CanAddToAvailableRecipes(TSubclassOf< UFGRecipe > recipe) const{ return bool(); }
bool AFGRecipeManager::ShouldAddRecipeByEvent(TSubclassOf< UFGRecipe > recipe) const{ return bool(); }
void AFGRecipeManager::PopulateAvailableBuildings(){ }
void AFGRecipeManager::PopulateAllRecipesList(){ }
void AFGRecipeManager::Internal_FindRecipesByIngredient(TSubclassOf< UFGItemDescriptor > ingredient, const TArray< TSubclassOf< UFGRecipe > >& recipeList, TArray< TSubclassOf< UFGRecipe > >& out_recipes, bool ignoreUniqueCheck) const{ }
void AFGRecipeManager::Internal_FindRecipesByProduct(TSubclassOf< UFGItemDescriptor > product, const TArray< TSubclassOf< UFGRecipe > >& recipeList, TArray< TSubclassOf< UFGRecipe > >& out_recipes, bool ignoreUniqueCheck) const{ }
void AFGRecipeManager::OnRep_NumAvailableRecipes(){ }
void AFGRecipeManager::OnRep_NumTotalRecipes(){ }
