// This file has been automatically generated by the Unreal Header Implementation tool

#include "WheeledVehicles/FGSplinePathMovementComponent.h"
#include "Net/UnrealNetwork.h"

#if DEBUG_SELF_DRIVING
void UFGSplinePathMovementComponent::DrawDebug(int debugLevel) const{ }
#endif 
#if DEBUG_SELF_DRIVING
void UFGSplinePathMovementComponent::DrawDebugVehicle(int visualDebugLevel, int textualDebugLevel){ }
#endif 
UFGSplinePathMovementComponent::UFGSplinePathMovementComponent() : Super() {
	this->mVehicle = nullptr;
	this->mTargetList = nullptr;
	this->mPauseTarget = nullptr;
	this->mTarget = nullptr;
	this->mPreviousTarget = nullptr;
	this->mSimulatedLocationOffset = FVector::ZeroVector;
	this->mEndOfPath = false;
	this->mServerStartTime = 0.0;
	this->mServerPauseTime = 0.0;
	this->mIsMoving = false;
}
void UFGSplinePathMovementComponent::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(UFGSplinePathMovementComponent, mVehicle);
	DOREPLIFETIME(UFGSplinePathMovementComponent, mTargetList);
	DOREPLIFETIME(UFGSplinePathMovementComponent, mPauseTarget);
	DOREPLIFETIME(UFGSplinePathMovementComponent, mSimulatedLocationOffset);
	DOREPLIFETIME(UFGSplinePathMovementComponent, mEndOfPath);
	DOREPLIFETIME(UFGSplinePathMovementComponent, mServerStartTime);
	DOREPLIFETIME(UFGSplinePathMovementComponent, mServerPauseTime);
	DOREPLIFETIME(UFGSplinePathMovementComponent, mIsMoving);
}
void UFGSplinePathMovementComponent::BeginPlay(){ Super::BeginPlay(); }
void UFGSplinePathMovementComponent::EndPlay(const EEndPlayReason::Type endPlayReason){ Super::EndPlay(endPlayReason); }
void UFGSplinePathMovementComponent::TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction){ }
void UFGSplinePathMovementComponent::TicTac(float DeltaTime){ }
void UFGSplinePathMovementComponent::OnBecameTheChosenWheeledVehicle(){ }
void UFGSplinePathMovementComponent::RestoreEssentialClaims(){ }
void UFGSplinePathMovementComponent::DestroyPath_Server(){ }
void UFGSplinePathMovementComponent::AddDynamicStops_Server(const TArray< FVector >& stops){ }
void UFGSplinePathMovementComponent::StartSplinePathMovement_Server( AFGTargetPoint* target){ }
void UFGSplinePathMovementComponent::StartSplinePathMovement_Multi_Implementation( AFGTargetPoint* target){ }
void UFGSplinePathMovementComponent::TransitionToSimulation(){ }
void UFGSplinePathMovementComponent::SetPaused(bool isPaused){ }
const FVector& UFGSplinePathMovementComponent::GetSimulatedLocation(){ return *(new FVector); }
const FRotator& UFGSplinePathMovementComponent::GetSimulatedRotation(){ return *(new FRotator); }
void UFGSplinePathMovementComponent::SetIsDocked(bool isDocked){ }
void UFGSplinePathMovementComponent::SetIsBlocked( AFGWheeledVehicleInfo* blockingVehicle){ }
void UFGSplinePathMovementComponent::ResetIsBlocked(){ }
void UFGSplinePathMovementComponent::DrawTargetDebug(bool drawSearchPoints) const{ }
void UFGSplinePathMovementComponent::ResetIsDeadlocked(bool removeDeadlock){ }
void UFGSplinePathMovementComponent::SetDeadlockId(int deadlockId, bool isInHardDeadlock){ }
float UFGSplinePathMovementComponent::GetTimeSpentOnRegularPath() const{ return float(); }
void UFGSplinePathMovementComponent::ResetTarget(bool resetStatus){ }
const TArray< FVector >& UFGSplinePathMovementComponent::GetSearchPoints() const{ return *(new TArray< FVector >); }
bool UFGSplinePathMovementComponent::TryClaim( AFGTargetPoint* target, bool essentialsOnly){ return bool(); }
void UFGSplinePathMovementComponent::GetShortestRotation(FRotator& rotation){ }
bool UFGSplinePathMovementComponent::HasData() const{ return bool(); }
void UFGSplinePathMovementComponent::CalculateSimulatedPosition(float clientCorrection){ }
float UFGSplinePathMovementComponent::GetServerTime() const{ return float(); }
void UFGSplinePathMovementComponent::OnRep_PauseTarget(){ }
void UFGSplinePathMovementComponent::OnRep_ServerStartTime(){ }
void UFGSplinePathMovementComponent::OnRep_IsMoving(){ }
bool UFGSplinePathMovementComponent::TickSplinePathMovement(double deltaTime){ return bool(); }
FVector UFGSplinePathMovementComponent::GetSimulationLocation(){ return FVector(); }
void UFGSplinePathMovementComponent::AdvanceOnSplinePath(){ }
void UFGSplinePathMovementComponent::TryClaimTarget(){ }
void UFGSplinePathMovementComponent::SetTarget( AFGTargetPoint* newTarget, bool resetStatus){ }
float UFGSplinePathMovementComponent::GetStartTime(float adjustment){ return float(); }
void UFGSplinePathMovementComponent::SetStartTime(float startTime){ }
bool UFGSplinePathMovementComponent::ShouldAdjustClient() const{ return bool(); }
