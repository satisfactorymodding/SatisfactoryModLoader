// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGResearchTree.h"
#include "UObject/ObjectSaveContext.h"
#include "FGSchematic.h"

FPrimaryAssetId UFGResearchTree::GetPrimaryAssetId() const {
	return FPrimaryAssetId(StaticClass()->GetFName(), FPackageName::GetShortFName(GetOutermost()->GetFName()));
}
FText UFGResearchTree::GetPreUnlockDisplayName(TSubclassOf<UFGResearchTree> inClass) {
	return inClass.GetDefaultObject()->mPreUnlockDisplayName;
}
FText UFGResearchTree::GetDisplayName(TSubclassOf<UFGResearchTree> inClass) {
	return inClass.GetDefaultObject()->mDisplayName;
}
FText UFGResearchTree::GetPreUnlockDescription(TSubclassOf<UFGResearchTree> inClass) {
	return inClass.GetDefaultObject()->mPreUnlockDescription;
}
FText UFGResearchTree::GetPostUnlockDescription(TSubclassOf<UFGResearchTree> inClass) {
	return inClass.GetDefaultObject()->mPostUnlockDescription;
}
FSlateBrush UFGResearchTree::GetResearchTreeIcon(TSubclassOf<UFGResearchTree> inClass) {
	return inClass.GetDefaultObject()->mResearchTreeIcon;
}
void UFGResearchTree::SetNodes(TSubclassOf<UFGResearchTree> inClass, TArray<UFGResearchTreeNode*> nodes) {
	inClass.GetDefaultObject()->mNodes = nodes;
}
TArray<class UFGResearchTreeNode*> UFGResearchTree::GetNodes(TSubclassOf<UFGResearchTree> inClass) {
	return inClass.GetDefaultObject()->mNodes;
}
TArray<class UFGAvailabilityDependency*> UFGResearchTree::GetUnlockDependencies(TSubclassOf<UFGResearchTree> inClass) {
	return inClass.GetDefaultObject()->mUnlockDependencies;
}

#if WITH_EDITOR
// Lazily initialize research tree node reflection properties for faster access
namespace
{
	// This function does things that are generally frowned upon
	// because it has to make do with what the game provides. Do
	// not do this unless you have no other choice and know what
	// you are doing.
	UClass* GetResearchTreeNodeClass()
	{
		// Saving a raw (i.e. not UPROPERTY) pointer to an UObject
		// is a terrible idea unless one knows what they are doing
		// as the GC (Garbage Collector) does not keep track of it.
		static UClass* ResearchTreeNodeClass = NULL;
		if (ResearchTreeNodeClass == NULL) {
			// Hardcoding Blueprint asset paths is also a terrible idea because
			// the editor cannot update the code when the Blueprint is moved or
			// renamed. This will not prevent deletion of the Blueprint either.
			ResearchTreeNodeClass = LoadClass<UFGResearchTreeNode>(NULL, TEXT("/Game/FactoryGame/Schematics/Research/BPD_ResearchTreeNode.BPD_ResearchTreeNode_C"));
			if (ResearchTreeNodeClass) {
				// Make sure class is not garbage collected because
				// the GC does not know we are referencing it here.
				ResearchTreeNodeClass->AddToRoot();
			}
		}
		return ResearchTreeNodeClass;
	}

	FStructProperty* GetNodeDataStructProperty(UClass* ResearchTreeNodeClass)
	{
		static FStructProperty* NodeDataStructProperty = NULL;
		if (ResearchTreeNodeClass && !NodeDataStructProperty) {
			NodeDataStructProperty = CastField<FStructProperty>(ResearchTreeNodeClass->FindPropertyByName(TEXT("mNodeDataStruct")));
		}
		return NodeDataStructProperty;
	}

	FClassProperty* GetSchematicStructProperty(FStructProperty* NodeDataStructProperty)
	{
		static FClassProperty* SchematicStructProperty = NULL;
		if (NodeDataStructProperty && !SchematicStructProperty) {
			// Generated structs names contain GUIDs, so we can't use FindPropertyByName
			for (FField* StructProp = NodeDataStructProperty->Struct->ChildProperties; StructProp; StructProp = StructProp->Next) {
				if (FClassProperty* ClassProp = CastField<FClassProperty>(StructProp)) {
					if (ClassProp->MetaClass->IsChildOf(UFGSchematic::StaticClass())) {
						SchematicStructProperty = ClassProp;
						break;
					}
				}
			}
		}
		return SchematicStructProperty;
	}
}

EDataValidationResult UFGResearchTree::IsDataValid(FDataValidationContext& validationContext ) const {
	// MODDING IMPLEMENTATION
	EDataValidationResult ValidationResult = Super::IsDataValid(validationContext);

	// Exit early if the research tree has no nodes
	const TArray<UFGResearchTreeNode*> Nodes = UFGResearchTree::GetNodes(GetClass());
	if (Nodes.IsEmpty()) {
		return ValidationResult;
	}

	// UFGResearchTreeNode::GetNodeSchematic is not implemented due to placeholder assets
	// so we read its property directly
	UClass* ResearchTreeNodeClass = GetResearchTreeNodeClass();
	FStructProperty* NodeDataStructProperty = GetNodeDataStructProperty(ResearchTreeNodeClass);
	FClassProperty* SchematicStructProperty = GetSchematicStructProperty(NodeDataStructProperty);

	if (!ResearchTreeNodeClass || !NodeDataStructProperty || !SchematicStructProperty) {
		validationContext.AddWarning(NSLOCTEXT("ResearchTree", "Validation_ReflectionFailed", "Could not retrieve properties to validate using reflection, validation not performed"));
		return ValidationResult;
	}

	for (UFGResearchTreeNode* Node : Nodes) {
		if (!Node->IsA(ResearchTreeNodeClass)) {
			continue;
		}
		const void* NodeDataStructPtr = NodeDataStructProperty->ContainerPtrToValuePtr<void>(Node);
		const UClass* SchematicClass = Cast<UClass>(SchematicStructProperty->GetPropertyValue_InContainer(NodeDataStructPtr));
	
		if (SchematicClass == nullptr) {
			validationContext.AddError(NSLOCTEXT("ResearchTree", "Validation_NullSchematic", "Null Schematic found. Was the content it previously referenced deleted or moved?"));
			ValidationResult = EDataValidationResult::Invalid;
		}			
	}
	
	return ValidationResult;
}
#endif

#if WITH_EDITOR
void UFGResearchTree::PreSave(FObjectPreSaveContext SaveContext){ }
#endif 
#if WITH_EDITOR
void UFGResearchTree::UpdateAssetBundleData(){ }
#endif 
#if WITH_EDITORONLY_DATA
#endif 
void UFGResearchTree::PostLoad(){ Super::PostLoad(); }
TArray< EEvents > UFGResearchTree::GetRelevantEvents(TSubclassOf< UFGResearchTree > inClass){ return TArray<EEvents>(); }
EResearchTreeStatus UFGResearchTree::GetResearchTreeStatus(TSubclassOf< UFGResearchTree > inClass, UObject* worldContext){ return EResearchTreeStatus(); }
