// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGSchematic.h"
#include "UObject/ObjectSaveContext.h"
#include "Unlocks/FGUnlockRecipe.h"

FPrimaryAssetId UFGSchematic::GetPrimaryAssetId() const {
	return FPrimaryAssetId(StaticClass()->GetFName(), FPackageName::GetShortFName(GetOutermost()->GetFName()));
}
ESchematicType UFGSchematic::GetType(TSubclassOf<UFGSchematic> inClass) {
	if (inClass)
		return inClass.GetDefaultObject()->mType;
	else
		return ESchematicType();
}
FText UFGSchematic::GetSchematicDisplayName(TSubclassOf<UFGSchematic> inClass) {
	if (inClass)
		return inClass.GetDefaultObject()->mDisplayName;
	else
		return FText();
}
TSubclassOf<class UFGSchematicCategory> UFGSchematic::GetSchematicCategory(TSubclassOf<UFGSchematic> inClass) {
	if (inClass)
		return inClass.GetDefaultObject()->mSchematicCategory;
	else
		return TSubclassOf<class UFGSchematicCategory>();
}
void UFGSchematic::GetSubCategories(TSubclassOf<UFGSchematic> inClass, TArray<TSubclassOf<UFGSchematicCategory>> &out_subCategories) {
	if (inClass)
		out_subCategories = inClass.GetDefaultObject()->mSubCategories;
}
TArray<FItemAmount> UFGSchematic::GetCost(TSubclassOf<UFGSchematic> inClass) {
	if (inClass)
		return inClass.GetDefaultObject()->mCost;
	else
		return TArray<FItemAmount>();
}
TArray<class UFGUnlock*> UFGSchematic::GetUnlocks(TSubclassOf<UFGSchematic> inClass) {
	if (inClass)
		return inClass.GetDefaultObject()->mUnlocks;
	else
		return TArray<UFGUnlock*>();
}
int32 UFGSchematic::GetTechTier(TSubclassOf<UFGSchematic> inClass) {
	if (inClass)
		return inClass.GetDefaultObject()->mTechTier;
	else
		return int32();
}
float UFGSchematic::GetTimeToComplete(TSubclassOf<UFGSchematic> inClass) {
	if (inClass)
		return inClass.GetDefaultObject()->mTimeToComplete;
	else
		return float();
}
FSlateBrush UFGSchematic::GetItemIcon(TSubclassOf<UFGSchematic> inClass) {
	if (inClass)
		return inClass.GetDefaultObject()->mSchematicIcon;
	else
		return FSlateBrush();
}

#if WITH_EDITOR
EDataValidationResult UFGSchematic::IsDataValid(FDataValidationContext& validationContext ) const {
	// MODDING IMPLEMENTATION
	EDataValidationResult ValidationResult = Super::IsDataValid(validationContext);

	const TArray<UFGUnlock*> Unlocks = UFGSchematic::GetUnlocks(GetClass());
	for (UFGUnlock* Unlock : Unlocks) {
		if (const UFGUnlockRecipe* UnlockRecipe = Cast<UFGUnlockRecipe>(Unlock)) {
			if (UnlockRecipe->GetRecipesToUnlock().Contains(nullptr)) {
				validationContext.AddError(NSLOCTEXT("Schematic", "SchematicValidation_NullRecipe", "Null recipe entry found in schematic. Was the content it previously referenced deleted or moved?"));
				ValidationResult = EDataValidationResult::Invalid;
			}
		}
	}

	if (mType == ESchematicType::EST_Milestone && (!mSchematicIcon.IsSet() || !IsValid(mSchematicIcon.GetResourceObject()))) {
		validationContext.AddError(NSLOCTEXT("Schematic", "SchematicValidation_InvalidIcon", "Invalid icon set for schematic. This will cause the milestone to not display its unlocks or cost in the HUB."));
		ValidationResult = EDataValidationResult::Invalid;
	}

	return ValidationResult;
}
#endif

#if WITH_EDITOR
void UFGSchematic::PreSave(FObjectPreSaveContext saveContext){ }
#endif 
#if WITH_EDITOR
void UFGSchematic::UpdateAssetBundleData(){ }
#endif 
#if WITH_EDITOR
void UFGSchematic::AddRecipe(TSubclassOf< UFGSchematic > inClass, TSubclassOf<  UFGRecipe > recipe){ }
void UFGSchematic::MigrateDataToNewDependencySystem(){ }
#endif 
#if WITH_EDITORONLY_DATA
#endif 
UFGSchematic::UFGSchematic() : Super() {
	this->mType = ESchematicType::EST_Custom;
	this->mDisplayName = INVTEXT("");
	this->mDescription = INVTEXT("");
	this->mSchematicCategory = nullptr;
	this->mMenuPriority = 0.0;
	this->mTimeToComplete = 600.0;
	this->mIsPlayerSpecific = false;
	this->mSmallSchematicIcon = nullptr;
	this->mDependenciesBlocksSchematicAccess = false;
	this->mHiddenUntilDependenciesMet = false;
	this->mDependsOnSchematic = nullptr;
}
void UFGSchematic::PostLoad(){ Super::PostLoad(); }
void UFGSchematic::Serialize(FArchive& ar){ Super::Serialize(ar); }
FText UFGSchematic::GetSchematicDescription(TSubclassOf< UFGSchematic > inClass){ return FText(); }
FGameplayTag UFGSchematic::GetStatisticGameplayTag(TSubclassOf< UFGSchematic > inClass){ return FGameplayTag(); }
float UFGSchematic::GetMenuPriority(TSubclassOf< UFGSchematic > inClass){ return float(); }
bool UFGSchematic::GetIsPlayerSpecific(TSubclassOf< UFGSchematic > inClass){ return bool(); }
void UFGSchematic::GetRelevantUnlockedShopSchematics(UObject* worldContext, TSubclassOf< UFGSchematic > inClass, TArray< TSubclassOf< UFGSchematic > >& out_schematics){ }
void UFGSchematic::GetRelevantShopSchematics(TSubclassOf< UFGSchematic > inClass, TArray< TSubclassOf< UFGSchematic > >& out_schematics){ }
UTexture2D* UFGSchematic::GetSmallIcon(TSubclassOf< UFGSchematic > inClass){ return nullptr; }
bool UFGSchematic::AreSchematicDependenciesMet(TSubclassOf< UFGSchematic > inClass, UObject* worldContext){ return bool(); }
void UFGSchematic::GetSchematicDependencies(TSubclassOf< UFGSchematic > inClass, TArray<  UFGAvailabilityDependency* >& out_schematicDependencies){ }
bool UFGSchematic::GetHiddenUntilDependenciesMet(TSubclassOf< UFGSchematic > inClass){ return bool(); }
ESchematicState UFGSchematic::GetSchematicState(TSubclassOf< UFGSchematic > inClass, UObject* worldContext){ return ESchematicState(); }
bool UFGSchematic::CanGiveAccessToSchematic(TSubclassOf< UFGSchematic > inClass, UObject* worldContext){ return bool(); }
bool UFGSchematic::IsRepeatPurchasesAllowed(TSubclassOf< UFGSchematic > inClass){ return bool(); }
void UFGSchematic::SortByMenuPriority(TArray< TSubclassOf< UFGSchematic > >& schematics){ }
TArray< EEvents > UFGSchematic::GetRelevantEvents(TSubclassOf< UFGSchematic > inClass){ return TArray<EEvents>(); }
bool UFGSchematic::IsIncludedInBuild(TSubclassOf< UFGSchematic > inClass){ return bool(); }
FGameplayTag UFGSchematic::GetSchematicUnlockTag(TSubclassOf< UFGSchematic > inClass){ return FGameplayTag(); }
