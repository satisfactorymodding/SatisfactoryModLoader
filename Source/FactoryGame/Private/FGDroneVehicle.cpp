// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGDroneVehicle.h"

#ifdef DEBUG_DRONES
void UFGDroneAction::DisplayDebugInformation(){ }
#endif 
UFGDroneAction::UFGDroneAction() : Super() {
	this->mDrone = nullptr;
}
void UFGDroneAction::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
bool UFGDroneAction::NeedTransform_Implementation(){ return bool(); }
bool UFGDroneAction::ShouldSave_Implementation() const{ return bool(); }
void UFGDroneAction::PushAction(UFGDroneAction* pAction){ }
#ifdef DEBUG_DRONES
void UFGDroneAction_Timed::DisplayDebugInformation(){ }
#endif 
UFGDroneAction_Timed::UFGDroneAction_Timed() : Super() {

}
void UFGDroneAction_Timed::Tick(float dt){ }
bool UFGDroneAction_Timed::IsDone() const{ return bool(); }
#ifdef DEBUG_DRONES
void UFGDroneAction_TraversePath::DisplayDebugInformation(){ }
#endif 
UFGDroneAction_TraversePath::UFGDroneAction_TraversePath() : Super() {
	this->mStopAtDestination = false;
	this->mFlyingMode = EDroneFlyingMode::DFM_None;
}
void UFGDroneAction_TraversePath::SetPath(const TArray<FVector>& Path, EDroneFlyingMode FlyingMode, bool StopAtDestination){ }
void UFGDroneAction_TraversePath::Begin(){ }
void UFGDroneAction_TraversePath::Tick(float dt){ }
void UFGDroneAction_TraversePath::ReceiveActionEvent(EDroneActionEvent ActionEvent, void* EventData){ }
bool UFGDroneAction_TraversePath::IsDone() const{ return bool(); }
void UFGDroneAction_TraversePath::GotoNextDestination(){ }
#ifdef DEBUG_DRONES
void UFGDroneAction_RequestDocking::DisplayDebugInformation(){ }
#endif 
UFGDroneAction_RequestDocking::UFGDroneAction_RequestDocking() : Super() {
	this->mStation = nullptr;
	this->mCurrentState = EDroneDockingRequestState::STravelToQueueLocation;
	this->mShouldTransferItems = false;
	this->mTotalQueueTime = 0.0;
	this->mQueuePosition = -1;
}
void UFGDroneAction_RequestDocking::SetStation( AFGBuildableDroneStation* Station, bool ShouldTransferItems){ }
void UFGDroneAction_RequestDocking::Begin(){ }
void UFGDroneAction_RequestDocking::End(){ }
void UFGDroneAction_RequestDocking::MoveToDesignatedQueuePosition(EDroneFlyingMode FlyingMode){ }
void UFGDroneAction_RequestDocking::Tick(float dt){ }
void UFGDroneAction_RequestDocking::ReceiveActionEvent(EDroneActionEvent ActionEvent, void* EventData){ }
bool UFGDroneAction_RequestDocking::IsDone() const{ return bool(); }
UFGDroneAction_DockingSequence::UFGDroneAction_DockingSequence() : Super() {
	this->mStation = nullptr;
	this->mShouldTransferItems = false;
}
void UFGDroneAction_DockingSequence::SetStation( AFGBuildableDroneStation* Station, bool ShouldTransferItems){ }
void UFGDroneAction_DockingSequence::Begin(){ }
void UFGDroneAction_DockingSequence::End(){ }
float UFGDroneAction_DockingSequence::GetActionDuration() const{ return float(); }
UFGDroneAction_TakeoffSequence::UFGDroneAction_TakeoffSequence() : Super() {
	this->mStation = nullptr;
	this->mNewTravelDestination = nullptr;
	this->mHasNewPairedStation = false;
}
void UFGDroneAction_TakeoffSequence::SetStation( AFGBuildableDroneStation* Station){ }
void UFGDroneAction_TakeoffSequence::Begin(){ }
void UFGDroneAction_TakeoffSequence::End(){ }
float UFGDroneAction_TakeoffSequence::GetActionDuration() const{ return float(); }
void UFGDroneAction_TakeoffSequence::ReceiveActionEvent(EDroneActionEvent ActionEvent, void* EventData){ }
void UFGDroneAction_TravelStartSequence::SetDestination(const FVector& Destination){ }
void UFGDroneAction_TravelStartSequence::Begin(){ }
void UFGDroneAction_TravelStartSequence::End(){ }
float UFGDroneAction_TravelStartSequence::GetActionDuration() const{ return float(); }
AFGDroneVehicle::AFGDroneVehicle() : Super() {
	this->mStorageInventory = nullptr;
	this->mBatteryInventory = nullptr;
	this->mInventorySize = 20;
	this->mBatteryStorageSize = 1;
	this->mDockingSequenceDuration = 0.0;
	this->mTakeoffSequenceDuration = 0.0;
	this->mTravelStartSequenceDuration = 0.0;
	this->mFlyingSpeed = 0.0;
	this->mTravelingSpeed = 0.0;
	this->mFlyingStoppingDistance = 0.0;
	this->mTravelingStoppingDistance = 0.0;
	this->mTurningStrength = 0.0;
	this->mCurrentPowerLevel = 0.0;
	this->mCurrentTripPowerCost = 0.0;
	this->mCurrentTripInformation.TripDuration = 0.0;
	this->mCurrentTripInformation.IncomingItemCount = 0;
	this->mCurrentTripInformation.OutgoingItemCount = 0;
	this->mCurrentTripInformation.IncomingItemStacks = 0.0;
	this->mCurrentTripInformation.OutgoingItemStacks = 0.0;
	this->mIsBraking = false;
	this->mCurrentVelocity.X = 0.0;
	this->mCurrentVelocity.Y = 0.0;
	this->mCurrentVelocity.Z = 0.0;
	this->mCurrentDestination.X = 0.0;
	this->mCurrentDestination.Y = 0.0;
	this->mCurrentDestination.Z = 0.0;
	this->mDesiredFacingDirection.X = 0.0;
	this->mDesiredFacingDirection.Y = 0.0;
	this->mDesiredFacingDirection.Z = 0.0;
	this->mCurrentFlyingMode = EDroneFlyingMode::DFM_None;
	this->mCurrentDockingState.State = EDroneDockingState::DS_UNDOCKED;
	this->mCurrentDockingState.StateStartTime = 0.0;
	this->mStopAtDestination = false;
	this->mDockedStation = nullptr;
	this->mHomeStation = nullptr;
	this->mCurrentTripDestinationStation = nullptr;
	this->mCurrentAction = nullptr;
}
void AFGDroneVehicle::BeginPlay(){ }
void AFGDroneVehicle::Tick(float DeltaTime){ }
void AFGDroneVehicle::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGDroneVehicle, mIsBraking);
	DOREPLIFETIME(AFGDroneVehicle, mCurrentVelocity);
	DOREPLIFETIME(AFGDroneVehicle, mDesiredFacingDirection);
	DOREPLIFETIME(AFGDroneVehicle, mCurrentFlyingMode);
	DOREPLIFETIME(AFGDroneVehicle, mCurrentDockingState);
	DOREPLIFETIME(AFGDroneVehicle, mDockedStation);
}
bool AFGDroneVehicle::IsUseable_Implementation() const{ return bool(); }
void AFGDroneVehicle::Dismantle_Implementation(){ }
void AFGDroneVehicle::OnIsSimulatedChanged(){ }
void AFGDroneVehicle::GainedSignificance_Implementation(){ }
void AFGDroneVehicle::LostSignificance_Implementation(){ }
void AFGDroneVehicle::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
FText AFGDroneVehicle::GetActorRepresentationText(){ return FText(); }
void AFGDroneVehicle::NotifyPairedStationUpdated( AFGBuildableDroneStation* NewPairedStation){ }
void AFGDroneVehicle::OnUndocked(){ }
void AFGDroneVehicle::OnDockedStationDestroyed(){ }
void AFGDroneVehicle::OnBeginLoadVehicle_Implementation(){ }
void AFGDroneVehicle::OnBeginUnloadVehicle_Implementation(){ }
void AFGDroneVehicle::OnTransferComplete_Implementation(){ }
TArray<FVector> AFGDroneVehicle::GeneratePathToDestination(const FVector& CurrentLocation, const FVector& Destination, UWorld* World){ return TArray<FVector>(); }
void AFGDroneVehicle::SetCurrentDestination(const FVector& NewDestination, EDroneFlyingMode FlyingMode, bool StopAtDestination){ }
void AFGDroneVehicle::StopMoving(){ }
void AFGDroneVehicle::BeginDocking( AFGBuildableDroneStation* station){ }
void AFGDroneVehicle::UpdateDockingQueuePosition(int NewPosition){ }
float AFGDroneVehicle::GetSpeedForFlyingMode(EDroneFlyingMode Mode) const{ return float(); }
float AFGDroneVehicle::GetStoppingDistanceForFlyingMode(EDroneFlyingMode Mode) const{ return float(); }
float AFGDroneVehicle::GetTimeSinceDockingStateChanged() const{ return float(); }
void AFGDroneVehicle::SetHomeStation( AFGBuildableDroneStation* station){ }
bool AFGDroneVehicle::GrabRequiredBatteriesForTrip( AFGBuildableDroneStation* FromStation,  AFGBuildableDroneStation* ToStation, bool AllowTravelWithoutCost){ return bool(); }
bool AFGDroneVehicle::TravelToStation( AFGBuildableDroneStation* station, bool ShouldTransferItems){ return bool(); }
void AFGDroneVehicle::BeginNewTrip( AFGBuildableDroneStation* Station){ }
void AFGDroneVehicle::EndCurrentTrip(bool Completed){ }
void AFGDroneVehicle::SetFacingDirection(const FVector& Direction){ }
void AFGDroneVehicle::StartDockingSequence_Implementation( AFGBuildableDroneStation* Station){ }
void AFGDroneVehicle::EndDockingSequence_Implementation( AFGBuildableDroneStation* Station, bool ShouldTransferItems){ }
void AFGDroneVehicle::StartTakeoffSequence_Implementation( AFGBuildableDroneStation* Station){ }
void AFGDroneVehicle::EndTakeoffSequence_Implementation( AFGBuildableDroneStation* Station){ }
void AFGDroneVehicle::StartTravelStartSequence_Implementation(){ }
void AFGDroneVehicle::EndTravelStartSequence_Implementation(){ }
void AFGDroneVehicle::OnRep_IsBraking(){ }
void AFGDroneVehicle::OnRep_FlyingMode(){ }
void AFGDroneVehicle::OnRep_DockingState(){ }
void AFGDroneVehicle::OnRep_DockedStation(){ }
void AFGDroneVehicle::OnSignificanceUpdate(){ }
void AFGDroneVehicle::ClearAllActions(bool KeepCurrentAction){ }
void AFGDroneVehicle::SetNewFlyingMode(EDroneFlyingMode Mode){ }
void AFGDroneVehicle::SetDockingState(EDroneDockingState State){ }
bool AFGDroneVehicle::ConsumeBatteriesForPower(float PowerRequirement){ return bool(); }
void AFGDroneVehicle::CalculateInventoryPotentialPower(){ }
