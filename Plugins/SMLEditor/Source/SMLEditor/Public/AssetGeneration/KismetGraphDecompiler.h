#pragma once
#include "CoreMinimal.h"
#include "AssetGeneration/KismetIntermediateFormat.h"
#include "EdGraphSchema_K2.h"

class UK2Node_CreateDelegate;
class UK2Node_BaseMCDelegate;

struct SMLEDITOR_API FKismetTerminalAsKeyType {
public:
    TSharedPtr<FKismetTerminal> Terminal;
    FORCEINLINE FKismetTerminalAsKeyType(const TSharedPtr<FKismetTerminal>& Terminal) : Terminal(Terminal) {}

    FORCEINLINE bool operator==(const FKismetTerminalAsKeyType& Other) const {
        return Terminal->operator==(*Other.Terminal);
    }
};

FORCEINLINE uint32 GetTypeHash(const FKismetTerminalAsKeyType& Key) {
    return GetTypeHash(*Key.Terminal);
}

class SMLEDITOR_API FKismetGraphDecompiler {
public:
    /** Constructs decompiler object for provided function and graph */
    FKismetGraphDecompiler(UFunction* Function, UEdGraph* Graph);

    /** Initializes decompiler with the compiled kismet statement list */
    void Initialize(const TArray<TSharedPtr<FKismetCompiledStatement>>& Statements);
private:
    void ConnectMakeStructNodePinsWithTerminals(UK2Node* MakeStructNode, TSharedPtr<FKismetTerminal> StructTerminal);
    
    UEdGraphNode* CreateMakeMapNode();
    UEdGraphNode* CreateMakeSetNode();
    UEdGraphNode* CreateMakeArrayNode();

    UEdGraphNode* CreateCastNode(bool bIsMetaCast);
    UEdGraphNode* CreateAssignmentNode();
    UEdGraphNode* CreateMakeStructNode(TSharedPtr<FKismetTerminal> StructTerminal);
    UEdGraphNode* CreateSetFieldsInStructNode(TSharedPtr<FKismetTerminal> StructTerminal);
    UEdGraphNode* CreateStructMemberSetNode(TSharedPtr<FKismetTerminal> StructTerminal);
    UEdGraphNode* CreateCopyNode();
    UEdGraphNode* CreateDelegateSetNode();
    UEdGraphNode* CreateVariableSetNode();
    UEdGraphNode* CreateVariableSetByRefNode();
    UEdGraphNode* CreateMakeDelegateNode();
    UEdGraphNode* CreateMulticastDelegateNode(TSubclassOf<UK2Node_BaseMCDelegate> NodeClass);
    UEdGraphNode* CreateFunctionCallNode();
    
    UEdGraphNode* GenerateNodeForStatement();

    /** Returns true if local variable in question was created manually by the user and not auto generated by kismet compiler */
	bool IsUserCreatedLocalVariable(TSharedPtr<FKismetTerminal> Terminal) { return false; }; // TODO: Replace dummy body

    /** Returns true if variable in question is a local variable, even if it is located in class but still considered local */
	bool IsLocalVariable(TSharedPtr<FKismetTerminal> Terminal) { return false; } // TODO: Replace dummy body

    /** Resolves UStruct type of the provided context terminal object by analyzing it's type. Obviously only valid for terminals used as contexts */
    UStruct* ResolveContextTerminalType(TSharedPtr<FKismetTerminal> Terminal);

    /** Retrieves current statement from the list, possibly with an offset. Does not advance reader index */
    FORCEINLINE TSharedPtr<FKismetCompiledStatement> PeekStatement(int32 Offset = 0) {
        return CompiledStatements[CurrentStatementIndex + Offset];
    }

    /** Retrieves current statement from the list and advances current statement index */
    FORCEINLINE TSharedPtr<FKismetCompiledStatement> PopStatement() {
        return CompiledStatements[CurrentStatementIndex++];
    }

    /** Retrieves first kismet graph node with provided class and asserts if it's not found */
    template<typename T>
    FORCEINLINE T* FindFirstGraphNodeOfClass() {
        TArray<T*> FoundKismetNodes;
        EditorGraph->GetNodesOfClass<T>(FoundKismetNodes);
        check(FoundKismetNodes.Num());
        return FoundKismetNodes[0];
    }
    
    /** Function we are currently reconstructing code for */
    UFunction* Function;

    /** Blueprint owner of this graph */
    UBlueprint* OwnerBlueprint;
    /** Graph containing source code for edited function */
    UEdGraph* EditorGraph;
    
    /** Collection of statements we are decompiling */
    TArray<TSharedPtr<FKismetCompiledStatement>> CompiledStatements;
    int32 CurrentStatementIndex;

    /** Map of intermediate variable terminals to node outputs which caused their generation */
    TMap<FKismetTerminalAsKeyType, UEdGraphPin*> IntermediateVariableHandles;

    /** After code generation, pin specified as the key will be automatically connected to the input exec pin of the value node */
    TMap<UEdGraphPin*, TSharedPtr<FKismetCompiledStatement>> ExecPinPatchUpMap;

    /** Map of pins to connect to terminals after all nodes have been generated */
    TMap<UEdGraphPin*, TSharedPtr<FKismetTerminal>> TerminalPatchUpMap;

    /** Map of the statement into the input exec pin of node generated by it */
    TMap<TSharedPtr<FKismetCompiledStatement>, UEdGraphPin*> NodeExecPinInputMap;

    /** Terminal specified as the key is the same thing as the terminal specified as value, and value terminal should be actually used for key code generation */
    TMap<FKismetTerminalAsKeyType, TSharedPtr<FKismetTerminal>> PassThroughTerminals;

    /** Map of create delegate nodes to patch up after terminals have been connected */
    TMap<UK2Node_CreateDelegate*, FName> CreateDelegatePatchUpMap;
};
